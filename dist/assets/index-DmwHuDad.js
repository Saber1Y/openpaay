import{b as H,ax as s,aJ as V,aA as p,aB as R,az as z,ay as d,aI as X,aC as Z,av as $}from"./index-8_JFJoco.js";import{r as q}from"./bn-D9Kp_-TR.js";var G=q();const J=H(G),K="bignumber/5.8.0";var E=J.BN;const l=new s(K),A={},B=9007199254740991;let F=!1;class h{constructor(r,n){r!==A&&l.throwError("cannot call constructor directly; use BigNumber.from",s.errors.UNSUPPORTED_OPERATION,{operation:"new (BigNumber)"}),this._hex=n,this._isBigNumber=!0,Object.freeze(this)}fromTwos(r){return u(i(this).fromTwos(r))}toTwos(r){return u(i(this).toTwos(r))}abs(){return this._hex[0]==="-"?h.from(this._hex.substring(1)):this}add(r){return u(i(this).add(i(r)))}sub(r){return u(i(this).sub(i(r)))}div(r){return h.from(r).isZero()&&c("division-by-zero","div"),u(i(this).div(i(r)))}mul(r){return u(i(this).mul(i(r)))}mod(r){const n=i(r);return n.isNeg()&&c("division-by-zero","mod"),u(i(this).umod(n))}pow(r){const n=i(r);return n.isNeg()&&c("negative-power","pow"),u(i(this).pow(n))}and(r){const n=i(r);return(this.isNegative()||n.isNeg())&&c("unbound-bitwise-result","and"),u(i(this).and(n))}or(r){const n=i(r);return(this.isNegative()||n.isNeg())&&c("unbound-bitwise-result","or"),u(i(this).or(n))}xor(r){const n=i(r);return(this.isNegative()||n.isNeg())&&c("unbound-bitwise-result","xor"),u(i(this).xor(n))}mask(r){return(this.isNegative()||r<0)&&c("negative-width","mask"),u(i(this).maskn(r))}shl(r){return(this.isNegative()||r<0)&&c("negative-width","shl"),u(i(this).shln(r))}shr(r){return(this.isNegative()||r<0)&&c("negative-width","shr"),u(i(this).shrn(r))}eq(r){return i(this).eq(i(r))}lt(r){return i(this).lt(i(r))}lte(r){return i(this).lte(i(r))}gt(r){return i(this).gt(i(r))}gte(r){return i(this).gte(i(r))}isNegative(){return this._hex[0]==="-"}isZero(){return i(this).isZero()}toNumber(){try{return i(this).toNumber()}catch{c("overflow","toNumber",this.toString())}return null}toBigInt(){try{return BigInt(this.toString())}catch{}return l.throwError("this platform does not support BigInt",s.errors.UNSUPPORTED_OPERATION,{value:this.toString()})}toString(){return arguments.length>0&&(arguments[0]===10?F||(F=!0,l.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")):arguments[0]===16?l.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()",s.errors.UNEXPECTED_ARGUMENT,{}):l.throwError("BigNumber.toString does not accept parameters",s.errors.UNEXPECTED_ARGUMENT,{})),i(this).toString(10)}toHexString(){return this._hex}toJSON(r){return{type:"BigNumber",hex:this.toHexString()}}static from(r){if(r instanceof h)return r;if(typeof r=="string")return r.match(/^-?0x[0-9a-f]+$/i)?new h(A,w(r)):r.match(/^-?[0-9]+$/)?new h(A,w(new E(r))):l.throwArgumentError("invalid BigNumber string","value",r);if(typeof r=="number")return r%1&&c("underflow","BigNumber.from",r),(r>=B||r<=-B)&&c("overflow","BigNumber.from",r),h.from(String(r));const n=r;if(typeof n=="bigint")return h.from(n.toString());if(V(n))return h.from(p(n));if(n)if(n.toHexString){const e=n.toHexString();if(typeof e=="string")return h.from(e)}else{let e=n._hex;if(e==null&&n.type==="BigNumber"&&(e=n.hex),typeof e=="string"&&(R(e)||e[0]==="-"&&R(e.substring(1))))return h.from(e)}return l.throwArgumentError("invalid BigNumber value","value",r)}static isBigNumber(r){return!!(r&&r._isBigNumber)}}function w(t){if(typeof t!="string")return w(t.toString(16));if(t[0]==="-")return t=t.substring(1),t[0]==="-"&&l.throwArgumentError("invalid hex","value",t),t=w(t),t==="0x00"?t:"-"+t;if(t.substring(0,2)!=="0x"&&(t="0x"+t),t==="0x")return"0x00";for(t.length%2&&(t="0x0"+t.substring(2));t.length>4&&t.substring(0,4)==="0x00";)t="0x"+t.substring(4);return t}function u(t){return h.from(w(t))}function i(t){const r=h.from(t).toHexString();return r[0]==="-"?new E("-"+r.substring(3),16):new E(r.substring(2),16)}function c(t,r,n){const e={fault:t,operation:r};return n!=null&&(e.value=n),l.throwError(t,s.errors.NUMERIC_FAULT,e)}function Q(t){return new E(t,36).toString(16)}const W="rlp/5.8.0",g=new s(W);function _(t){const r=[];for(;t;)r.unshift(t&255),t>>=8;return r}function k(t,r,n){let e=0;for(let o=0;o<n;o++)e=e*256+t[r+o];return e}function I(t){if(Array.isArray(t)){let e=[];if(t.forEach(function(f){e=e.concat(I(f))}),e.length<=55)return e.unshift(192+e.length),e;const o=_(e.length);return o.unshift(247+o.length),o.concat(e)}z(t)||g.throwArgumentError("RLP object must be BytesLike","object",t);const r=Array.prototype.slice.call(d(t));if(r.length===1&&r[0]<=127)return r;if(r.length<=55)return r.unshift(128+r.length),r;const n=_(r.length);return n.unshift(183+n.length),n.concat(r)}function Y(t){return p(I(t))}function C(t,r,n,e){const o=[];for(;n<r+1+e;){const f=v(t,n);o.push(f.result),n+=f.consumed,n>r+1+e&&g.throwError("child data too short",s.errors.BUFFER_OVERRUN,{})}return{consumed:1+e,result:o}}function v(t,r){if(t.length===0&&g.throwError("data too short",s.errors.BUFFER_OVERRUN,{}),t[r]>=248){const n=t[r]-247;r+1+n>t.length&&g.throwError("data short segment too short",s.errors.BUFFER_OVERRUN,{});const e=k(t,r+1,n);return r+1+n+e>t.length&&g.throwError("data long segment too short",s.errors.BUFFER_OVERRUN,{}),C(t,r,r+1+n,n+e)}else if(t[r]>=192){const n=t[r]-192;return r+1+n>t.length&&g.throwError("data array too short",s.errors.BUFFER_OVERRUN,{}),C(t,r,r+1,n)}else if(t[r]>=184){const n=t[r]-183;r+1+n>t.length&&g.throwError("data array too short",s.errors.BUFFER_OVERRUN,{});const e=k(t,r+1,n);r+1+n+e>t.length&&g.throwError("data array too short",s.errors.BUFFER_OVERRUN,{});const o=p(t.slice(r+1+n,r+1+n+e));return{consumed:1+n+e,result:o}}else if(t[r]>=128){const n=t[r]-128;r+1+n>t.length&&g.throwError("data too short",s.errors.BUFFER_OVERRUN,{});const e=p(t.slice(r+1,r+1+n));return{consumed:1+n,result:e}}return{consumed:1,result:p(t[r])}}function cr(t){const r=d(t),n=v(r,0);return n.consumed!==r.length&&g.throwArgumentError("invalid rlp data","data",t),n.result}const j="address/5.8.0",m=new s(j);function O(t){R(t,20)||m.throwArgumentError("invalid address","address",t),t=t.toLowerCase();const r=t.substring(2).split(""),n=new Uint8Array(40);for(let o=0;o<40;o++)n[o]=r[o].charCodeAt(0);const e=d($(n));for(let o=0;o<40;o+=2)e[o>>1]>>4>=8&&(r[o]=r[o].toUpperCase()),(e[o>>1]&15)>=8&&(r[o+1]=r[o+1].toUpperCase());return"0x"+r.join("")}const rr=9007199254740991;function tr(t){return Math.log10?Math.log10(t):Math.log(t)/Math.LN10}const U={};for(let t=0;t<10;t++)U[String(t)]=String(t);for(let t=0;t<26;t++)U[String.fromCharCode(65+t)]=String(10+t);const T=Math.floor(tr(rr));function nr(t){t=t.toUpperCase(),t=t.substring(4)+t.substring(0,2)+"00";let r=t.split("").map(e=>U[e]).join("");for(;r.length>=T;){let e=r.substring(0,T);r=parseInt(e,10)%97+r.substring(e.length)}let n=String(98-parseInt(r,10)%97);for(;n.length<2;)n="0"+n;return n}function P(t){let r=null;if(typeof t!="string"&&m.throwArgumentError("invalid address","address",t),t.match(/^(0x)?[0-9a-fA-F]{40}$/))t.substring(0,2)!=="0x"&&(t="0x"+t),r=O(t),t.match(/([A-F].*[a-f])|([a-f].*[A-F])/)&&r!==t&&m.throwArgumentError("bad address checksum","address",t);else if(t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){for(t.substring(2,4)!==nr(t)&&m.throwArgumentError("bad icap checksum","address",t),r=Q(t.substring(4));r.length<40;)r="0"+r;r=O("0x"+r)}else m.throwArgumentError("invalid address","address",t);return r}function gr(t){let r=null;try{r=P(t.from)}catch{m.throwArgumentError("missing from address","transaction",t)}const n=X(d(h.from(t.nonce).toHexString()));return P(Z($(Y([r,n])),12))}const er="properties/5.8.0";var ir=function(t,r,n,e){function o(f){return f instanceof n?f:new n(function(y){y(f)})}return new(n||(n=Promise))(function(f,y){function M(a){try{b(e.next(a))}catch(N){y(N)}}function D(a){try{b(e.throw(a))}catch(N){y(N)}}function b(a){a.done?f(a.value):o(a.value).then(M,D)}b((e=e.apply(t,r||[])).next())})};const x=new s(er);function or(t,r,n){Object.defineProperty(t,r,{enumerable:!0,value:n,writable:!1})}function lr(t,r){for(let n=0;n<32;n++){if(t[r])return t[r];if(!t.prototype||typeof t.prototype!="object")break;t=Object.getPrototypeOf(t.prototype).constructor}return null}function ar(t){return ir(this,void 0,void 0,function*(){const r=Object.keys(t).map(e=>{const o=t[e];return Promise.resolve(o).then(f=>({key:e,value:f}))});return(yield Promise.all(r)).reduce((e,o)=>(e[o.key]=o.value,e),{})})}function mr(t,r){(!t||typeof t!="object")&&x.throwArgumentError("invalid object","object",t),Object.keys(t).forEach(n=>{r[n]||x.throwArgumentError("invalid object key - "+n,"transaction:"+n,t)})}function pr(t){const r={};for(const n in t)r[n]=t[n];return r}const sr={bigint:!0,boolean:!0,function:!0,number:!0,string:!0};function L(t){if(t==null||sr[typeof t])return!0;if(Array.isArray(t)||typeof t=="object"){if(!Object.isFrozen(t))return!1;const r=Object.keys(t);for(let n=0;n<r.length;n++){let e=null;try{e=t[r[n]]}catch{continue}if(!L(e))return!1}return!0}return x.throwArgumentError(`Cannot deepCopy ${typeof t}`,"object",t)}function ur(t){if(L(t))return t;if(Array.isArray(t))return Object.freeze(t.map(r=>S(r)));if(typeof t=="object"){const r={};for(const n in t){const e=t[n];e!==void 0&&or(r,n,S(e))}return r}return x.throwArgumentError(`Cannot deepCopy ${typeof t}`,"object",t)}function S(t){return ur(t)}class wr{constructor(r){for(const n in r)this[n]=S(r[n])}}export{h as B,wr as D,gr as a,lr as b,S as c,or as d,mr as e,J as f,P as g,Y as h,cr as i,ar as r,pr as s};
