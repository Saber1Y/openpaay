{
  "version": 3,
  "sources": ["../../.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/src.ts/bignumber.ts", "../../.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/src.ts/_version.ts", "../../.pnpm/@ethersproject+bignumber@5.8.0/node_modules/@ethersproject/bignumber/src.ts/fixednumber.ts", "../../.pnpm/@ethersproject+constants@5.8.0/node_modules/@ethersproject/constants/src.ts/bignumbers.ts", "../../.pnpm/@ethersproject+constants@5.8.0/node_modules/@ethersproject/constants/src.ts/addresses.ts", "../../.pnpm/@ethersproject+constants@5.8.0/node_modules/@ethersproject/constants/src.ts/hashes.ts", "../../.pnpm/@ethersproject+rlp@5.8.0/node_modules/@ethersproject/rlp/src.ts/_version.ts", "../../.pnpm/@ethersproject+rlp@5.8.0/node_modules/@ethersproject/rlp/src.ts/index.ts", "../../.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/src.ts/_version.ts", "../../.pnpm/@ethersproject+address@5.8.0/node_modules/@ethersproject/address/src.ts/index.ts", "../../.pnpm/@ethersproject+properties@5.8.0/node_modules/@ethersproject/properties/src.ts/_version.ts", "../../.pnpm/@ethersproject+properties@5.8.0/node_modules/@ethersproject/properties/src.ts/index.ts"],
  "sourcesContent": ["\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n", "export const version = \"bignumber/5.8.0\";\n", "\"use strict\";\n\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\n\nconst _constructorGuard = { };\n\nconst Zero = BigNumber.from(0);\nconst NegativeOne = BigNumber.from(-1);\n\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value !== undefined) { params.value = value; }\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) { zeros += zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals: BigNumberish): string {\n\n    if (typeof(decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        } catch (e) { }\n    }\n\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\n\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n\n    const negative = value.lt(Zero);\n    if (negative) { value = value.mul(NegativeOne); }\n\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\n\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    } else {\n        value = whole + \".\" + fraction;\n    }\n\n    if (negative) { value = \"-\" + value; }\n\n    return value;\n}\n\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\n\n    if (decimals == null) { decimals = 0; }\n    const multiplier = getMultiplier(decimals);\n\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) { value = value.substring(1); }\n\n    if (value === \".\") {\n        logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) { whole = \"0\"; }\n    if (!fraction) { fraction = \"0\"; }\n\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") { fraction = \"0\"; }\n\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\n\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\n    if (negative) { wei = wei.mul(NegativeOne); }\n\n    return wei;\n}\n\n\nexport class FixedFormat {\n    readonly signed: boolean;\n    readonly width: number;\n    readonly decimals: number;\n    readonly name: string;\n    readonly _multiplier: string;\n\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n        this._multiplier = getMultiplier(decimals);\n\n        Object.freeze(this);\n    }\n\n    static from(value: any): FixedFormat {\n        if (value instanceof FixedFormat) { return value; }\n\n        if (typeof(value) === \"number\") {\n            value = `fixed128x${value}`\n        }\n\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n\n        if (typeof(value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            } else if (value === \"ufixed\") {\n                signed = false;\n            } else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        } else if (value) {\n            const check = (key: string, type: string, defaultValue: any): any => {\n                if (value[key] == null) { return defaultValue; }\n                if (typeof(value[key]) !== type) {\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            }\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n\n        if (width % 8) {\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n\n        if (decimals > 80) {\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\n    }\n}\n\nexport class FixedNumber {\n    readonly format: FixedFormat;\n    readonly _hex: string;\n    readonly _value: string;\n\n    readonly _isFixedNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n\n        this._isFixedNumber = true;\n\n        Object.freeze(this);\n    }\n\n    _checkFormat(other: FixedNumber): void {\n        if (this.format.name !== other.format.name) {\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n\n    addUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n\n    subUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n\n    mulUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n\n    divUnsafe(other: FixedNumber): FixedNumber {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n\n    floor(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    ceiling(): FixedNumber {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        let result = FixedNumber.from(comps[0], this.format);\n\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n\n        return result;\n    }\n\n    // @TODO: Support other rounding algorithms\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) { comps.push(\"0\"); }\n\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n\n        if (comps[1].length <= decimals) { return this; }\n\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n\n    isZero(): boolean {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n\n    isNegative(): boolean {\n        return (this._value[0] === \"-\");\n    }\n\n    toString(): string { return this._value; }\n\n    toHexString(width?: number): string {\n        if (width == null) { return this._hex; }\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    toFormat(format: FixedFormat | string): FixedNumber {\n        return FixedNumber.fromString(this._value, format);\n    }\n\n\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n\n        if (decimals == null) { decimals = 0; }\n        if (format == null) { format = \"fixed\"; }\n\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n\n\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        const numeric = parseFixed(value, fixedFormat.decimals);\n\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n\n        let hex: string = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        } else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\n        if (format == null) { format = \"fixed\"; }\n\n        const fixedFormat = FixedFormat.from(format);\n\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\n\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n    }\n\n    static from(value: any, format?: FixedFormat | string | number) {\n        if (typeof(value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        } catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n\n    static isFixedNumber(value: any): value is FixedNumber {\n        return !!(value && value._isFixedNumber);\n    }\n}\n\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n", "import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n", "export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n", "export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n", "export const version = \"rlp/5.8.0\";\n", "\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n", "export const version = \"address/5.8.0\";\n", "\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n", "export const version = \"properties/5.8.0\";\n", "\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["_BN", "logger", "_constructorGuard", "throwFault", "NegativeOne", "Zero", "version", "logger", "version", "length", "version", "logger", "version", "logger", "logger", "version", "logger", "version"]
}
