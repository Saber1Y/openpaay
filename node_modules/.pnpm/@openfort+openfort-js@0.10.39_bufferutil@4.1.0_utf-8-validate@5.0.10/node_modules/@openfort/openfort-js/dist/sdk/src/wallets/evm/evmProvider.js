import{Account as t}from"../../core/configuration/account.js";import{Authentication as e}from"../../core/configuration/authentication.js";import{OpenfortEvents as a,AccountTypeEnum as i}from"../../types/types.js";import{defaultChainRpcs as s}from"../../utils/chains/index.js";import{numberToHex as r}from"../../utils/crypto.js";import o from"../../utils/typedEventEmitter.js";import{addEthereumChain as n}from"./addEthereumChain.js";import{estimateGas as c}from"./estimateGas.js";import{getAssets as h}from"./getAssets.js";import{getCallStatus as d}from"./getCallsStatus.js";import{JsonRpcError as p,ProviderErrorCode as m,RpcErrorCode as l}from"./JsonRpcError.js";import{personalSign as w}from"./personalSign.js";import{registerSession as u}from"./registerSession.js";import{revokeSession as g}from"./revokeSession.js";import{sendCallsSync as f}from"./sendCallSync.js";import{sendCalls as S}from"./sendCalls.js";import{signTypedDataV4 as A}from"./signTypedDataV4.js";import{ProviderEvent as R}from"./types.js";import{prepareEOATransaction as _,parseTransactionRequest as v}from"./walletHelpers.js";class y{#t;#e;#a;#i;updatePolicy(t){this.#e=t}#s;#r;#o=null;#n;isOpenfort=!0;#c;constructor({storage:t,backendApiClients:e,openfortEventEmitter:i,policyId:s,ensureSigner:r,chains:n,validateAndRefreshSession:c}){this.#c=r,this.#t=t,this.#a=n,this.#e=s,this.#s=c,this.#n=e,this.#r=new o,i.on(a.ON_LOGOUT,this.#h),i.on(a.ON_SWITCH_ACCOUNT,this.#d)}#p=async()=>(this.#i||(this.#i=await this.#c()),this.#i);#h=async()=>{this.#i=void 0,this.#r.emit(R.ACCOUNTS_CHANGED,[])};#d=async t=>{this.#r.emit(R.ACCOUNTS_CHANGED,[t])};async getRpcProvider(){if(!this.#o){const e=await t.fromStorage(this.#t),a=e?.chainId||8453;await import("@ethersproject/providers").then(t=>{const e=this.#a?this.#a[a]:void 0;this.#o=new t.StaticJsonRpcProvider(e??s[a])})}if(!this.#o)throw new Error("RPC provider not initialized");return this.#o}async#m(a){switch(a.method){case"eth_accounts":{const e=await t.fromStorage(this.#t);return e?[e.address]:[]}case"eth_requestAccounts":{const e=await t.fromStorage(this.#t);if(e)return this.#r.emit(R.ACCOUNTS_CONNECT,{chainId:String(e.chainId)}),[e.address];throw new p(m.UNAUTHORIZED,"Unauthorized - must be authenticated and configured with a signer.")}case"eth_signTransaction":{const i=await t.fromStorage(this.#t),s=await this.#p(),r=await e.fromStorage(this.#t);if(!i||!r)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");const o=await this.getRpcProvider(),{chainId:n}=await o.detectNetwork(),[c]=a.params||[];c.chainId||(c.chainId=n.toString());const h=v(c),{serialize:d}=await import("@ethersproject/transactions"),l=t=>({legacy:0,eip2930:1,eip1559:2}[t]),{gas:w,...u}=h,g={...u,gasLimit:w,to:h.to??void 0,type:l(h.type)},f=d(g),{keccak256:S}=await import("@ethersproject/keccak256"),A=S(f);await this.#s();const R=await s.sign(A,!1,!1),{splitSignature:_}=await import("@ethersproject/bytes");return d(g,_(R))}case"eth_sendTransaction":{const[s,r,o]=await Promise.all([t.fromStorage(this.#t),this.#p(),e.fromStorage(this.#t)]);if(!s||!o)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");if(await this.#s(),s?.accountType===i.EOA){const[t]=a.params||[],e=await this.getRpcProvider(),i=await _(t,e,s.address),r=await this.#m({method:"eth_signTransaction",params:[i]});return this.#m({method:"eth_sendRawTransaction",params:[r]})}return(await f({params:a.params||[],signer:r,account:s,authentication:o,backendClient:this.#n,rpcProvider:await this.getRpcProvider(),policyId:this.#e})).receipt.transactionHash}case"eth_sendRawTransactionSync":{const[s,r,o]=await Promise.all([t.fromStorage(this.#t),this.#p(),e.fromStorage(this.#t)]);if(!s||!o)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");if(s?.accountType===i.EOA)throw new p(m.UNSUPPORTED_METHOD,`${a.method}: Method not supported`);return await this.#s(),await f({params:a.params||[],signer:r,account:s,authentication:o,backendClient:this.#n,rpcProvider:await this.getRpcProvider(),policyId:this.#e})}case"eth_estimateGas":{const i=await t.fromStorage(this.#t),s=await e.fromStorage(this.#t);if(!i||!s)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await c({params:a.params||[],account:i,authentication:s,backendClient:this.#n,policyId:this.#e})}case"eth_signTypedData":case"eth_signTypedData_v4":{const e=await t.fromStorage(this.#t),i=await this.#p();if(!e)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");await this.#s();const s=await this.getRpcProvider();return await A({method:a.method,params:a.params||[],signer:i,implementationType:e.implementationType||e.type,rpcProvider:s,account:e})}case"personal_sign":{const e=await t.fromStorage(this.#t);if(!e)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");const i=await this.#p();return await this.#s(),await w({params:a.params||[],signer:i,account:e})}case"eth_chainId":{const t=await this.getRpcProvider(),{chainId:e}=await t.detectNetwork();return r(e)}case"wallet_switchEthereumChain":{const t=await this.#p();if(!a.params||!Array.isArray(a.params)||0===a.params.length)throw new p(l.INVALID_PARAMS,"Invalid parameters for wallet_switchEthereumChain");await this.#s();try{const e=parseInt(a.params[0].chainId,16);await t.switchChain({chainId:e}),await import("@ethersproject/providers").then(t=>{const a=this.#a?this.#a[e]:void 0;this.#o=new t.StaticJsonRpcProvider(a??s[e])})}catch(t){const e=t;throw new p(l.INTERNAL_ERROR,`Failed to switch chain: ${e.message}`)}return null}case"wallet_addEthereumChain":{await this.#p();const t=await this.getRpcProvider();return await n({params:a.params||[],rpcProvider:t,storage:this.#t})}case"wallet_showCallsStatus":return null;case"wallet_getCallsStatus":{const s=await t.fromStorage(this.#t);if(s?.accountType===i.EOA)throw new p(m.UNSUPPORTED_METHOD,`${a.method}: Method not supported`);const r=await e.fromStorage(this.#t);if(!s||!r)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await d({params:a.params||{},authentication:r,backendClient:this.#n})}case"wallet_sendCalls":{const[s,r,o]=await Promise.all([t.fromStorage(this.#t),this.#p(),e.fromStorage(this.#t)]);if(s?.accountType===i.EOA)throw new p(m.UNSUPPORTED_METHOD,`${a.method}: Method not supported`);if(!s||!o)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");await this.#s();return await S({params:a.params?a.params[0].calls:[],signer:r,account:s,authentication:o,backendClient:this.#n,rpcProvider:await this.getRpcProvider(),policyId:this.#e})}case"wallet_grantPermissions":{const s=await t.fromStorage(this.#t);if(s?.accountType===i.EOA)throw new p(m.UNSUPPORTED_METHOD,`${a.method}: Method not supported`);const r=await this.#p(),o=await e.fromStorage(this.#t);if(!s||!o)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await u({params:a.params||[],signer:r,account:s,authentication:o,backendClient:this.#n,policyId:this.#e})}case"wallet_revokePermissions":{const i=await t.fromStorage(this.#t),s=await this.#p(),r=await e.fromStorage(this.#t);if(!i||!r)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await g({params:a.params||[],signer:s,account:i,authentication:r,backendClient:this.#n,policyId:this.#e})}case"wallet_getCapabilities":{const e=await t.fromStorage(this.#t);if(e?.accountType===i.EOA)throw new p(m.UNSUPPORTED_METHOD,`${a.method}: Method not supported`);const s=await this.getRpcProvider(),{chainId:o}=await s.detectNetwork();return{[r(o)]:{permissions:{supported:!0,signerTypes:["account","key"],keyTypes:["secp256k1"],permissionTypes:["contract-calls"]},paymasterService:{supported:!0},atomicBatch:{supported:!0}}}}case"wallet_getAssets":{const i=await t.fromStorage(this.#t),s=await e.fromStorage(this.#t);if(!i||!s)throw new p(m.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await h({params:a.params?.[0],account:i,authentication:s,backendClient:this.#n})}case"eth_gasPrice":case"eth_getBalance":case"eth_sendRawTransaction":case"eth_getCode":case"eth_getStorageAt":case"eth_call":case"eth_blockNumber":case"eth_getBlockByHash":case"eth_getBlockByNumber":case"eth_getTransactionByHash":case"eth_getTransactionReceipt":case"eth_getTransactionCount":return(await this.getRpcProvider()).send(a.method,a.params||[]);default:throw new p(m.UNSUPPORTED_METHOD,`${a.method}: Method not supported`)}}async request(t){try{return this.#m(t)}catch(t){if(t instanceof p)throw t;if(t instanceof Error)throw new p(l.INTERNAL_ERROR,t.message);throw new p(l.INTERNAL_ERROR,"Internal error")}}on(t,e){this.#r.on(t,e)}removeListener(t,e){this.#r.off(t,e)}}export{y as EvmProvider};
