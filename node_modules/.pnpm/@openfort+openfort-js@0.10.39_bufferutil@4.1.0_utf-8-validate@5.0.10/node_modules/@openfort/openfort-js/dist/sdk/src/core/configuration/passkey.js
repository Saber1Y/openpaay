import{humanId as e}from"human-id";class t{iValidByteLengths=[16,24,32];rpId;rpName;timeoutMillis;derivedKeyLengthBytes;extractableKey;constructor({rpId:e,rpName:t,timeoutMillis:r,derivedKeyLengthBytes:i,extractableKey:s}){if(this.rpId=e,this.rpName=t,this.timeoutMillis=r??6e4,this.derivedKeyLengthBytes=i??32,this.extractableKey=s??!0,!this.iValidByteLengths.includes(this.derivedKeyLengthBytes))throw new Error(`Invalid key byte length ${this.derivedKeyLengthBytes}`)}static randomPasskeyName(){return e({capitalize:!0,separator:" "})}getChallengeBytes(){return crypto.getRandomValues(new Uint8Array(32))}async deriveFromAssertion(e){const t=e.getClientExtensionResults();if(!t)throw new Error("Passkey fetch failed");const r=t.prf;if(!r||!r.results)throw new Error("PRF extension not supported or missing results");const i=r.results.first;return await crypto.subtle.importKey("raw",i,{name:"AES-CBC",length:this.derivedKeyLengthBytes},this.extractableKey,["encrypt","decrypt"])}async createPasskey({id:e,displayName:t,seed:r}){const i={challenge:this.getChallengeBytes(),rp:{id:this.rpId,name:this.rpName},user:{id:(new TextEncoder).encode(e),name:e,displayName:t},pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-257}],authenticatorSelection:{residentKey:"required",userVerification:"required"},extensions:{prf:{eval:{first:(new TextEncoder).encode(r)}}},timeout:this.timeoutMillis,attestation:"direct"},s=await navigator.credentials.create({publicKey:i});if(s){return{id:btoa(String.fromCharCode(...new Uint8Array(s.rawId))),displayName:t,key:new Uint8Array(await crypto.subtle.exportKey("raw",await this.deriveFromAssertion(s)))}}throw new Error("could not create passkey")}base64ToArrayBuffer(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r.buffer}async deriveKey({id:e,seed:t}){const r=e,i=await navigator.credentials.get({publicKey:{challenge:this.getChallengeBytes(),rpId:this.rpId,allowCredentials:[{id:this.base64ToArrayBuffer(r),type:"public-key"}],userVerification:"required",extensions:{prf:{eval:{first:(new TextEncoder).encode(t)}}}}});return this.deriveFromAssertion(i)}async deriveAndExportKey({id:e,seed:t}){if(!this.extractableKey)throw new Error("Derived keys cannot be exported if extractableKey is not set to true");const r=await this.deriveKey({id:e,seed:t});return new Uint8Array(await crypto.subtle.exportKey("raw",r))}}export{t as PasskeyHandler};
