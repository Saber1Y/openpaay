import{isAxiosError as R}from"axios";var O;!function(R){R.AUTHENTICATION_ERROR="AUTHENTICATION_ERROR",R.INVALID_CONFIGURATION="INVALID_CONFIGURATION",R.NOT_LOGGED_IN_ERROR="NOT_LOGGED_IN_ERROR",R.ALREADY_LOGGED_IN_ERROR="ALREADY_LOGGED_IN_ERROR",R.REFRESH_TOKEN_ERROR="REFRESH_TOKEN_ERROR",R.USER_REGISTRATION_ERROR="USER_REGISTRATION_ERROR",R.LOGOUT_ERROR="LOGOUT_ERROR",R.OPERATION_NOT_SUPPORTED_ERROR="OPERATION_NOT_SUPPORTED_ERROR",R.MISSING_SIGNER_ERROR="MISSING_SIGNER_ERROR",R.USER_NOT_AUTHORIZED_ON_ECOSYSTEM="USER_NOT_AUTHORIZED_ON_ECOSYSTEM",R.INTERNAL_ERROR="INTERNAL_ERROR"}(O||(O={}));class E extends Error{type;data;constructor(R,O,E={}){super(R),this.type=O,this.data=E}}const _=async(O,_,N)=>{try{return await O()}catch(O){let e;const I={};let T;R(O)?(T=O.response?.status,e=O.response?.data?.error&&function(R){return"type"in R&&"message"in R}(O.response.data.error)?O.response.data.error.message:O.message):e=O.message;const t=void 0!==T&&_[T]?_[T]:_.default,s=new E(e,t,I);throw void 0!==T&&_[T]||N?.(O,s),s}};export{E as OpenfortError,O as OpenfortErrorType,_ as withOpenfortError};
