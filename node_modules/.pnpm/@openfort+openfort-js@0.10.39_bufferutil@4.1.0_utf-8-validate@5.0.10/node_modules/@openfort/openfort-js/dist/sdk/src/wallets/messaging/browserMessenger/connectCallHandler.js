import{serializeError as e}from"./errorSerialization.js";import{isCallMessage as r}from"./guards.js";import{formatMethodPath as a,getMethodAtMethodPath as t}from"./methodSerialization.js";import n from"./namespace.js";import o from"./PenpalError.js";import s from"./Reply.js";const i=(r,a,t)=>({namespace:n,channel:r,type:"REPLY",callId:a,isError:!0,...t instanceof Error?{value:e(t),isSerializedErrorInstance:!0}:{value:t}}),l=(e,l,c,d)=>{let m=!1;const p=async p=>{if(m)return;if(!r(p))return;d?.(`Received ${a(p.methodPath)}() call`,p);const{methodPath:f,args:h,id:u}=p;let g,y;try{const e=t(f,l);if(!e)throw new o("METHOD_NOT_FOUND",`Method \`${a(f)}\` is not found.`);let r=await e(...h);r instanceof s&&(y=r.transferables,r=await r.value),g={namespace:n,channel:c,type:"REPLY",callId:u,value:r}}catch(e){g=i(c,u,e)}if(!m)try{d?.(`Sending ${a(f)}() reply`,g),e.sendMessage(g,y)}catch(r){throw"DataCloneError"===r.name&&(g=i(c,u,r),d?.(`Sending ${a(f)}() reply`,g),e.sendMessage(g)),r}};return e.addMessageHandler(p),()=>{m=!0,e.removeMessageHandler(p)}};export{l as default};
