import{Authentication as e}from"../core/configuration/authentication.js";import{PasskeyHandler as t}from"../core/configuration/passkey.js";import{OpenfortError as a,OpenfortErrorType as r,withOpenfortError as o}from"../core/errors/openfortError.js";import{SDKConfiguration as s}from"../core/config/config.js";import{Account as n}from"../core/configuration/account.js";import{StorageKeys as i}from"../storage/istorage.js";import{OpenfortEvents as c,AccountTypeEnum as d}from"../types/types.js";class y{iframeManager;storage;backendApiClients;passkeyHandler;eventEmitter;constructor(e,t,a,r,o){this.iframeManager=e,this.storage=t,this.backendApiClients=a,this.passkeyHandler=r,this.eventEmitter=o}async createPasskey(e){const a=await this.passkeyHandler.createPasskey({id:t.randomPasskeyName(),displayName:"Openfort - Embedded Wallet",seed:e});return{id:a.id,key:a.key}}async configure(t){const i=await e.fromStorage(this.storage);if(!i)throw new a("No access token found",r.NOT_LOGGED_IN_ERROR);const d=s.getInstance();if(!d)throw new a("Configuration not found",r.INVALID_CONFIGURATION);const y=await n.fromStorage(this.storage);let p;if(y){const e={account:y.id,...t.entropy&&{entropy:{...t.entropy.recoveryPassword&&{recoveryPassword:t.entropy.recoveryPassword},...t.entropy.encryptionSession&&{encryptionSession:t.entropy.encryptionSession},..."passkey"===y.recoveryMethod&&{passkey:{id:y.recoveryMethodDetails?.passkeyId,env:y.recoveryMethodDetails?.passkeyEnv,key:await t.getPasskeyKeyFn(y.recoveryMethodDetails?.passkeyId??"")}}}}},a=await this.iframeManager.recover(e);p=a.account}else{const e=await this.backendApiClients.accountsApi.getAccountsV2({user:i.player,accountType:t.accountType,chainType:t.chainType},{headers:{authorization:`Bearer ${d.baseConfiguration.publishableKey}`,"x-player-token":i.token,"x-auth-provider":i.thirdPartyProvider,"x-token-type":i.thirdPartyTokenType}});if(0===e.data.data.length){const e=t.entropy?.passkey?await this.createPasskey(i.player):void 0,a={accountType:t.accountType,chainType:t.chainType,chainId:t.chainId,...t.entropy&&{entropy:{...t.entropy.recoveryPassword&&{recoveryPassword:t.entropy.recoveryPassword},...t.entropy.encryptionSession&&{encryptionSession:t.entropy.encryptionSession},...t.entropy.passkey&&{passkey:e}}}},r=await this.iframeManager.create(a);p=r.account}else{const a=e.data.data,r=a.find(e=>e.chainId===t.chainId),o=r||a[0],s={account:o.id,...t.entropy&&{entropy:{...t.entropy.recoveryPassword&&{recoveryPassword:t.entropy.recoveryPassword},...t.entropy.encryptionSession&&{encryptionSession:t.entropy.encryptionSession},..."passkey"===o.recoveryMethod&&{passkey:{id:o.recoveryMethodDetails?.passkeyId,env:o.recoveryMethodDetails?.passkeyEnv,key:await t.getPasskeyKeyFn(o.recoveryMethodDetails?.passkeyId??"")}}}}},n=await this.iframeManager.recover(s);if(p=n.account,!r){const e=await this.iframeManager.switchChain(t.chainId);p=e.account}}}return o(async()=>{const e=await this.backendApiClients.accountsApi.getAccountV2({id:p},{headers:{authorization:`Bearer ${d.baseConfiguration.publishableKey}`,"x-player-token":i.token,"x-auth-provider":i.thirdPartyProvider,"x-token-type":i.thirdPartyTokenType}}),t=new n({user:e.data.user,chainType:e.data.chainType,id:e.data.id,address:e.data.address,ownerAddress:e.data.ownerAddress,accountType:e.data.accountType,createdAt:e.data.createdAt,implementationAddress:e.data.smartAccount?.implementationAddress,implementationType:e.data.smartAccount?.implementationType,chainId:e.data.chainId,salt:e.data.smartAccount?.salt,factoryAddress:e.data.smartAccount?.factoryAddress,recoveryMethod:n.parseRecoveryMethod(e.data.recoveryMethod),recoveryMethodDetails:e.data.recoveryMethodDetails});return t.save(this.storage),this.eventEmitter.emit(c.ON_SWITCH_ACCOUNT,e.data.address),t},{default:r.AUTHENTICATION_ERROR})}async sign(e,t,a,r){const o=await this.iframeManager.sign(e,t,a,r);return this.eventEmitter.emit(c.ON_SIGNED_MESSAGE,{message:e,signature:o}),o}async export(){return await this.iframeManager.export()}async switchChain({chainId:e}){const t=await n.fromStorage(this.storage);if(t?.accountType===d.EOA)new n({...t,chainId:e}).save(this.storage);else{const a=await this.iframeManager.switchChain(e);new n({...t,id:a.account,chainId:e}).save(this.storage)}}async create(t){const i=await this.iframeManager.create(t),d=await e.fromStorage(this.storage);if(!d)throw new a("No access token found",r.NOT_LOGGED_IN_ERROR);const y=s.getInstance();if(!y)throw new a("Configuration not found",r.INVALID_CONFIGURATION);return o(async()=>{const e=await this.backendApiClients.accountsApi.getAccountV2({id:i.account},{headers:{authorization:`Bearer ${y.baseConfiguration.publishableKey}`,"x-player-token":d.token,"x-auth-provider":d.thirdPartyProvider,"x-token-type":d.thirdPartyTokenType}}),t=new n({user:e.data.user,chainType:e.data.chainType,id:e.data.id,address:e.data.address,ownerAddress:e.data.ownerAddress,accountType:e.data.accountType,createdAt:e.data.createdAt,implementationType:e.data.smartAccount?.implementationType,chainId:e.data.chainId,implementationAddress:e.data.smartAccount?.implementationAddress,salt:e.data.smartAccount?.salt,factoryAddress:e.data.smartAccount?.factoryAddress,recoveryMethod:n.parseRecoveryMethod(e.data.recoveryMethod),recoveryMethodDetails:e.data.recoveryMethodDetails});return t.save(this.storage),this.eventEmitter.emit(c.ON_SWITCH_ACCOUNT,e.data.address),t},{default:r.AUTHENTICATION_ERROR})}async recover(t){const i=await this.iframeManager.recover(t),d=await e.fromStorage(this.storage);if(!d)throw new a("No access token found",r.NOT_LOGGED_IN_ERROR);const y=s.getInstance();if(!y)throw new a("Configuration not found",r.INVALID_CONFIGURATION);return o(async()=>{const e=await this.backendApiClients.accountsApi.getAccountV2({id:i.account},{headers:{authorization:`Bearer ${y.baseConfiguration.publishableKey}`,"x-player-token":d.token,"x-auth-provider":d.thirdPartyProvider,"x-token-type":d.thirdPartyTokenType}}),t=new n({user:e.data.user,chainType:e.data.chainType,id:e.data.id,address:e.data.address,ownerAddress:e.data.ownerAddress,accountType:e.data.accountType,createdAt:e.data.createdAt,implementationAddress:e.data.smartAccount?.implementationAddress,implementationType:e.data.smartAccount?.implementationType,chainId:e.data.chainId,salt:e.data.smartAccount?.salt,factoryAddress:e.data.smartAccount?.factoryAddress,recoveryMethod:n.parseRecoveryMethod(e.data.recoveryMethod),recoveryMethodDetails:e.data.recoveryMethodDetails});return t.save(this.storage),this.eventEmitter.emit(c.ON_SWITCH_ACCOUNT,e.data.address),t},{default:r.AUTHENTICATION_ERROR})}async setRecoveryMethod({recoveryMethod:e,recoveryPassword:t,encryptionSession:a,passkeyInfo:r}){await this.iframeManager.setRecoveryMethod(e,t,a,r?.passkeyKey,r?.passkeyId)}async disconnect(){await this.iframeManager.disconnect(),this.storage.remove(i.ACCOUNT)}}export{y as EmbeddedSigner};
