import{randomUUID as e}from"../../../utils/crypto.js";import{DEPRECATED_PENPAL_PARTICIPANT_ID as t}from"./backwardCompatibility.js";import s from"./connectCallHandler.js";import r from"./connectRemoteProxy.js";import n from"./getPromiseWithResolvers.js";import{isSynMessage as o,isAck1Message as a,isAck2Message as m}from"./guards.js";import{extractMethodPathsFromMethods as i}from"./methodSerialization.js";import c from"./namespace.js";import d from"./PenpalError.js";const p=({messenger:p,methods:h,timeout:l,channel:f,log:S})=>{const g=e();let u;const I=[];let y=!1;const A=i(h),{promise:N,resolve:C,reject:j}=n(),M=setTimeout(()=>{j(new d("CONNECTION_TIMEOUT",`Connection timed out after ${l}ms`))},l),R=()=>{for(const e of I)e()},T=()=>{if(y)return;I.push(s(p,h,f,S));const{remoteProxy:e,destroy:t}=r(p,f,S);I.push(t),clearTimeout(M),y=!0,C({remoteProxy:e,destroy:R})},k=()=>{const e={namespace:c,type:"SYN",channel:f,participantId:g};S?.("Sending handshake SYN",e);try{p.sendMessage(e)}catch(e){j(new d("TRANSMISSION_FAILED",e.message))}},v=e=>{o(e)&&(e=>{if(S?.("Received handshake SYN",e),e.participantId===u&&u!==t)return;if(u=e.participantId,k(),!(g>u||u===t))return;const s={namespace:c,channel:f,type:"ACK1",methodPaths:A};S?.("Sending handshake ACK1",s);try{p.sendMessage(s)}catch(e){j(new d("TRANSMISSION_FAILED",e.message))}})(e),a(e)&&(e=>{S?.("Received handshake ACK1",e);const t={namespace:c,channel:f,type:"ACK2"};S?.("Sending handshake ACK2",t);try{p.sendMessage(t)}catch(e){return void j(new d("TRANSMISSION_FAILED",e.message))}T()})(e),m(e)&&(e=>{S?.("Received handshake ACK2",e),T()})(e)};return p.addMessageHandler(v),I.push(()=>p.removeMessageHandler(v)),k(),N};export{p as default};
