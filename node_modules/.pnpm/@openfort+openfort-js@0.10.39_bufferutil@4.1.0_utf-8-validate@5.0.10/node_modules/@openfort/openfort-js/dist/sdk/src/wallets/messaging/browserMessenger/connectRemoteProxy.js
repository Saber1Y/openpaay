import{randomUUID as e}from"../../../utils/crypto.js";import t from"./CallOptions.js";import{deserializeError as r}from"./errorSerialization.js";import{isReplyMessage as o}from"./guards.js";import{formatMethodPath as a}from"./methodSerialization.js";import s from"./namespace.js";import n from"./PenpalError.js";const l=new Set(["apply","call","bind"]),i=(e,t,r=[])=>new Proxy(r.length?()=>{}:Object.create(null),{get(o,a){if("then"!==a)return r.length&&l.has(a)?Reflect.get(o,a):i(e,t,[...r,a])},apply:(t,o,a)=>e(r,a)}),c=e=>new n("CONNECTION_DESTROYED",`Method call ${a(e)}() failed due to destroyed connection`),d=(l,d,m)=>{let h=!1;const p=new Map,f=e=>{if(!o(e))return;const{callId:t,value:s,isError:n,isSerializedErrorInstance:l}=e,i=p.get(t);i&&(p.delete(t),m?.(`Received ${a(i.methodPath)}() call`,e),n?i.reject(l?r(s):s):i.resolve(s))};l.addMessageHandler(f);return{remoteProxy:i((r,o)=>{if(h)throw c(r);const i=e(),f=o[o.length-1],u=f instanceof t,{timeout:g,transferables:j}=u?f:{},w=u?o.slice(0,-1):o;return new Promise((e,t)=>{const o=void 0!==g?window.setTimeout(()=>{p.delete(i),t(new n("METHOD_CALL_TIMEOUT",`Method call ${a(r)}() timed out after ${g}ms`))},g):void 0;p.set(i,{methodPath:r,resolve:e,reject:t,timeoutId:o});try{const e={namespace:s,channel:d,type:"CALL",id:i,methodPath:r,args:w};m?.(`Sending ${a(r)}() call`,e),l.sendMessage(e,j)}catch(e){t(new n("TRANSMISSION_FAILED",e.message))}})},m),destroy:()=>{h=!0,l.removeMessageHandler(f);for(const{methodPath:e,reject:t,timeoutId:r}of p.values())clearTimeout(r),t(c(e));p.clear()}}};export{d as default};
