import{JsonRpcError as e,RpcErrorCode as t}from"./JsonRpcError.js";import{signMessage as a}from"./walletHelpers.js";const r=["types","domain","primaryType","message"],n=(a,n)=>{let s;if("string"==typeof a)try{s=JSON.parse(a)}catch(a){throw new e(t.INVALID_PARAMS,`Failed to parse typed data JSON: ${a}`)}else{if("object"!=typeof a)throw new e(t.INVALID_PARAMS,`Invalid typed data argument: ${a}`);s=a}if(!(e=>r.every(t=>t in e))(s))throw new e(t.INVALID_PARAMS,`Invalid typed data argument. The following properties are required: \n      ${r.join(", ")}`);const d=s.domain?.chainId;if(d&&("string"==typeof d&&(d.startsWith("0x")?s.domain.chainId=parseInt(d,16):s.domain.chainId=parseInt(d,10)),s.domain.chainId!==n))throw new e(t.INVALID_PARAMS,`Invalid chainId, expected ${n}`);return s},s=async({params:r,method:s,signer:d,implementationType:i,rpcProvider:o,account:p})=>{const c=r[0],h=r[1];if(!c||!h)throw new e(t.INVALID_PARAMS,`${s} requires an address and a typed data JSON`);const{chainId:m}=await o.detectNetwork(),I=n(h,m),y={...I.types};delete y.EIP712Domain;const{_TypedDataEncoder:A}=await import("@ethersproject/hash"),w=A.hash(I.domain,y,I.message);return await a({hash:w,implementationType:i,chainId:m,signer:d,address:c,ownerAddress:p.ownerAddress,factoryAddress:p.factoryAddress,salt:p.salt})};export{s as signTypedDataV4};
