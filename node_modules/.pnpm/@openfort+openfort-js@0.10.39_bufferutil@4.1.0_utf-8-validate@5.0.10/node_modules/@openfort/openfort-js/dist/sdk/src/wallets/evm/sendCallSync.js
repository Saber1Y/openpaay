import{withOpenfortError as e,OpenfortErrorType as t}from"../../core/errors/openfortError.js";import{AccountTypeEnum as a,AccountType as n}from"../../types/types.js";import{prepareAndSignAuthorization as s,serializeSignedAuthorization as o}from"../../utils/authorization.js";import{JsonRpcError as r,RpcErrorCode as i}from"./JsonRpcError.js";const c=e=>{const t=e?.logs?.[0];return{blockHash:t?.blockHash,blockNumber:e?.blockNumber?.toString(),contractAddress:void 0,cumulativeGasUsed:e?.gasUsed,effectiveGasPrice:e?.gasFee,from:void 0,gasUsed:e?.gasUsed,logs:e?.logs||[],logsBloom:void 0,status:1===e?.status?"success":0===e?.status?"reverted":void 0,to:e?.to,transactionHash:e?.transactionHash,transactionIndex:t?.transactionIndex,type:"eip1559",blobGasPrice:void 0,blobGasUsed:void 0,root:void 0}};async function d(e,t){try{const a=await e.getCode(t);return"0x"!==a&&a.length>2}catch{return!1}}const p=async({params:p,signer:l,account:u,authentication:T,backendClient:A,rpcProvider:h,policyId:g})=>{const E=p[0]?.capabilities?.paymasterService?.policy??g;let m;if(u.accountType===a.DELEGATED_ACCOUNT){const[e,t]=await Promise.all([d(h,u.address),h.getTransactionCount(u.address)]);if(!e){const e=await s({signer:l,accountAddress:u.address,contractAddress:u.implementationAddress,chainId:u.chainId,nonce:t});m=o(e)}}const I=await(async(a,n,s,o,c,d)=>{const p=a.map(e=>{if(!e.to)throw new r(i.INVALID_PARAMS,'wallet_sendCalls requires a "to" field');return{to:String(e.to),data:e.data?String(e.data):void 0,value:e.value?String(e.value):void 0}});return e(async()=>(await n.transactionIntentsApi.createTransactionIntent({createTransactionIntentRequest:{account:s.id,policy:c,signedAuthorization:d,chainId:s.chainId,interactions:p}},{headers:{authorization:`Bearer ${n.config.backend.accessToken}`,"x-player-token":o.token,"x-auth-provider":o.thirdPartyProvider,"x-token-type":o.thirdPartyTokenType}})).data,{default:t.AUTHENTICATION_ERROR})})(p,A,u,T,E,m).catch(e=>{throw new r(i.TRANSACTION_REJECTED,e.message)});if(I.response?.error.reason)throw new r(i.TRANSACTION_REJECTED,I.response?.error.reason);if(I?.nextAction?.payload?.signableHash){let a;a=[300,324].includes(u.chainId)||u.implementationType&&[n.CALIBUR].includes(u.implementationType)?await l.sign(I.nextAction.payload.signableHash,!1,!1):await l.sign(I.nextAction.payload.signableHash);const s=await e(async()=>await A.transactionIntentsApi.signature({id:I.id,signatureRequest:{signature:a}}),{default:t.AUTHENTICATION_ERROR}).catch(e=>{throw new r(i.TRANSACTION_REJECTED,e.message)});if(0===s.data.response?.status)throw new r(i.TRANSACTION_REJECTED,s.data.response?.error.reason);if(!s.data.response)throw new r(i.TRANSACTION_REJECTED,"No transaction response received");return{id:I.id,receipt:c(s.data.response)}}if(!I.response)throw new r(i.TRANSACTION_REJECTED,"No transaction response received");return{id:I.id,receipt:c(I.response)}};export{p as sendCallsSync};
