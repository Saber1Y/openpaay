import{withOpenfortError as t,OpenfortErrorType as e}from"../../core/errors/openfortError.js";import{AccountType as i}from"../../types/types.js";import{JsonRpcError as n,RpcErrorCode as a}from"./JsonRpcError.js";function s(t){return{data:(()=>{if("token-allowance"===t.type)throw new n(a.INVALID_PARAMS,"token-allowance policy is not supported with this account implementation.");if("gas-limit"===t.type)throw new n(a.INVALID_PARAMS,"gas-limit policy is not supported with this account implementation.");if("rate-limit"===t.type)throw new n(a.INVALID_PARAMS,"rate-limit policy is not supported with this account implementation.");return t.data})(),type:t.type.custom}}function o(t){if("native-token-transfer"===t.type)throw new n(a.INVALID_PARAMS,"native-token-transfer permission is not supported with this account implementation.");if("rate-limit"===t.type)throw new n(a.INVALID_PARAMS,"rate-limit permission is not supported with this account implementation.");if("gas-limit"===t.type)throw new n(a.INVALID_PARAMS,"gas-limit permission is not supported with this account implementation.");return{...t,policies:t?.policies?.map(s),required:t.required??!1,type:"string"==typeof t.type?t.type:t.type.custom}}function r(t){return{expiry:t.validUntil?Number(t.validUntil):0,grantedPermissions:t.whitelist?t.whitelist.map(e=>({type:"contract-call",data:{address:e,calls:[]},policies:[{data:{limit:t.limit},type:{custom:"usage-limit"}}]})):[],permissionsContext:t.id}}const p=async({params:s,signer:p,account:c,authentication:l,backendClient:d,policyId:m})=>{const y=await(async(i,s,r,p,c)=>{const l=i[0],d=Math.floor(Date.now()/1e3),m=Math.floor(new Date(Date.now()+1e3*l.expiry).getTime()/1e3),y=l.permissions.map(o),u=y.filter(t=>"contract-call"===t.type||"erc20-token-transfer"===t.type||"erc721-token-transfer"===t.type||"erc1155-token-transfer"===t.type).map(t=>t.data.address);let h,w=y.find(t=>"call-limit"===t.type)?.data;if(w=y[0]?.policies?.find(t=>"call-limit"===t.type)?.data?.limit,"signer"in l&&l.signer){if("keys"===l.signer.type)throw new n(a.INVALID_PARAMS,"Multi-key signers are not supported for session creation");"key"!==l.signer.type&&"account"!==l.signer.type||(h=l.signer.data.id)}else"account"in l&&l.account&&(h=l.account);if(!h)throw new n(a.INVALID_PARAMS,"Failed to request permissions - missing session address");const A=((t,e,i,n,a,s=!1,o,r,p,c)=>{const l={address:t,chainId:e,validAfter:i,validUntil:n,optimistic:s,whitelist:o,player:r,account:c};return a&&(l.policy=a),p&&(l.limit=p),l})(h,r.chainId,d,m,c,!1,u,p.player,w,r.id);return t(async()=>(await s.sessionsApi.createSession({createSessionRequest:A},{headers:{authorization:`Bearer ${s.config.backend.accessToken}`,"x-player-token":p.token,"x-auth-provider":p.thirdPartyProvider,"x-token-type":p.thirdPartyTokenType}})).data,{default:e.AUTHENTICATION_ERROR})})(s,d,c,l,m).catch(t=>{throw new n(a.TRANSACTION_REJECTED,t.message)});if(y?.nextAction?.payload?.signableHash){let s;s=[300,324].includes(c.chainId)||c.implementationType&&[i.CALIBUR].includes(c.implementationType)?await p.sign(y.nextAction.payload.signableHash,!1,!1):await p.sign(y.nextAction.payload.signableHash);return r(await t(async()=>(await d.sessionsApi.signatureSession({id:y.id,signatureRequest:{signature:s}})).data,{default:e.AUTHENTICATION_ERROR}).catch(t=>{throw new n(a.TRANSACTION_REJECTED,t.message)}))}if(!1===y.isActive)throw new n(a.TRANSACTION_REJECTED,"Failed to grant permissions");return r(y)};export{p as registerSession};
