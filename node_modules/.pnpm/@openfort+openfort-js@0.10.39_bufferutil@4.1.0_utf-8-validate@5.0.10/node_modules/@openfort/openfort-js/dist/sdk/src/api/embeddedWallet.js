import{BackendApiClients as e}from"../../../packages/internal/openapi-clients/dist/index.js";import{PasskeyHandler as t}from"../core/configuration/passkey.js";import{SDKConfiguration as r}from"../core/config/config.js";import{Account as s}from"../core/configuration/account.js";import{Authentication as a}from"../core/configuration/authentication.js";import{OpenfortError as i,OpenfortErrorType as n,withOpenfortError as o}from"../core/errors/openfortError.js";import{OpenfortEvents as d,RecoveryMethod as c,ChainTypeEnum as h,AccountTypeEnum as m,EmbeddedState as y}from"../types/types.js";import{debugLog as g}from"../utils/debug.js";import{EmbeddedSigner as l}from"../wallets/embedded.js";import{EvmProvider as p}from"../wallets/evm/evmProvider.js";import"../wallets/evm/types.js";import{announceProvider as f,openfortProviderInfo as A}from"../wallets/evm/provider/eip6963.js";import{signMessage as u}from"../wallets/evm/walletHelpers.js";import{IframeManager as w}from"../wallets/iframeManager.js";import{ReactNativeMessenger as I}from"../wallets/messaging/ReactNativeMessenger.js";import"../wallets/messaging/browserMessenger/backwardCompatibility.js";import v from"../wallets/messaging/browserMessenger/messengers/WindowMessenger.js";class M{storage;validateAndRefreshToken;ensureInitialized;eventEmitter;passkeyHandler;iframeManager=null;iframeManagerPromise=null;signer=null;signerPromise=null;provider=null;messagePoster=null;messenger=null;constructor(e,t,r,s,a){this.storage=e,this.validateAndRefreshToken=t,this.ensureInitialized=r,this.eventEmitter=s,this.passkeyHandler=a,this.eventEmitter.on(d.ON_LOGOUT,()=>{g("Handling logout event in EmbeddedWalletApi"),this.handleLogout()})}get backendApiClients(){const t=r.getInstance();if(!t)throw new i("Configuration not found",n.INVALID_CONFIGURATION);return new e({basePath:t.backendUrl,accessToken:t.baseConfiguration.publishableKey,nativeAppIdentifier:t.nativeAppIdentifier})}async getIframeManager(){if(g("[HANDSHAKE DEBUG] getIframeManager called"),this.iframeManager&&this.iframeManager.hasFailed&&(g("[HANDSHAKE DEBUG] Existing iframeManager has failed, clearing for recreation"),this.messenger&&(this.messenger.destroy(),this.messenger=null),this.iframeManager=null),this.iframeManager)return g("[HANDSHAKE DEBUG] Returning existing iframeManager instance"),this.iframeManager;if(this.iframeManagerPromise)return g("[HANDSHAKE DEBUG] Returning existing iframeManagerPromise"),this.iframeManagerPromise;g("[HANDSHAKE DEBUG] Creating new iframeManager"),this.iframeManagerPromise=this.createIframeManager();try{return g("[HANDSHAKE DEBUG] Awaiting iframeManager creation"),this.iframeManager=await this.iframeManagerPromise,g("[HANDSHAKE DEBUG] IframeManager created successfully"),this.iframeManagerPromise=null,this.iframeManager}catch(e){throw g("[HANDSHAKE DEBUG] Error creating iframeManager:",e),this.iframeManagerPromise=null,this.messenger&&(this.messenger.destroy(),this.messenger=null),this.iframeManager=null,e}}async createIframeManager(){g("[HANDSHAKE DEBUG] createIframeManager starting");const e=r.getInstance();if(!e)throw g("[HANDSHAKE DEBUG] Configuration not found"),new i("Configuration not found",n.INVALID_CONFIGURATION);let t;if(g("[HANDSHAKE DEBUG] Configuration found"),this.messagePoster)g("[HANDSHAKE DEBUG] Creating ReactNativeMessenger with messagePoster"),this.messenger&&(g("[HANDSHAKE DEBUG] Destroying old messenger before creating new one"),this.messenger.destroy()),this.messenger=new I(this.messagePoster),g("[HANDSHAKE DEBUG] Created new ReactNativeMessenger instance"),t=this.messenger;else{g("[HANDSHAKE DEBUG] Creating WindowMessenger for browser mode");const r=this.createIframe(e.iframeUrl),s=new URL(e.iframeUrl).origin;t=new v({remoteWindow:r.contentWindow,allowedOrigins:[s]}),g("[HANDSHAKE DEBUG] Created WindowMessenger")}return g("[HANDSHAKE DEBUG] Creating IframeManager instance"),new w(e,this.storage,t)}async ensureSigner(){if(this.iframeManager&&this.iframeManager.hasFailed&&(g("IframeManager has failed, clearing signer for recreation"),this.signer=null),this.signer)return this.signer;if(this.signerPromise)return this.signerPromise;this.signerPromise=this.createSigner();try{return this.signer=await this.signerPromise,this.signer}catch(e){throw this.signerPromise=null,e}finally{this.signerPromise=null}}async createSigner(){const e=await this.getIframeManager();return new l(e,this.storage,this.backendApiClients,this.passkeyHandler,this.eventEmitter)}createIframe(e){if("undefined"==typeof document)throw new i("Document is not available. Please provide a message poster for non-browser environments.",n.INVALID_CONFIGURATION);const t=document.getElementById("openfort-iframe");t&&t.remove();const r=document.createElement("iframe");return r.style.display="none",r.id="openfort-iframe",r.src=e,document.body.appendChild(r),r}async getPasskeyKey(e){const t=await a.fromStorage(this.storage);return await this.passkeyHandler.deriveAndExportKey({id:e,seed:t.player})}async getEntropy(e){switch(e.recoveryMethod){case c.PASSWORD:return{recoveryPassword:e.password};case c.AUTOMATIC:return{encryptionSession:e.encryptionSession};case c.PASSKEY:return{passkey:e.passkeyInfo?{id:e.passkeyInfo.passkeyId,key:e.passkeyInfo.passkeyKey||await this.getPasskeyKey(e.passkeyInfo.passkeyId)}:{}};default:throw new i("Invalid recovery method",n.INVALID_CONFIGURATION)}}async configure(e){await this.validateAndRefreshToken();const t=e.recoveryParams??{recoveryMethod:c.AUTOMATIC},[r,a]=await Promise.all([this.ensureSigner(),this.getEntropy(t)]),i={chainId:e.chainId,entropy:a,accountType:e.accountType??m.SMART_ACCOUNT,chainType:e.chainType??h.EVM,getPasskeyKeyFn:async e=>this.getPasskeyKey(e)},n=await r.configure(i);return{id:n.id,chainId:n.chainId,user:n.user,address:n.address,ownerAddress:n.ownerAddress,chainType:n.chainType,accountType:n.accountType,implementationType:n.implementationType,factoryAddress:n.factoryAddress,salt:n.salt,createdAt:n.createdAt,implementationAddress:n.implementationAddress,recoveryMethod:s.parseRecoveryMethod(n.recoveryMethod),recoveryMethodDetails:n.recoveryMethodDetails}}async create(e){await this.validateAndRefreshToken();const r=e.recoveryParams??{recoveryMethod:c.AUTOMATIC},o=await a.fromStorage(this.storage);if(!o)throw new i("missing authentication",n.AUTHENTICATION_ERROR);if(r.recoveryMethod===c.PASSKEY){const e=await this.passkeyHandler.createPasskey({id:t.randomPasskeyName(),displayName:"Openfort - Embedded Wallet",seed:o?.player??""});r.passkeyInfo={passkeyId:e.id,passkeyKey:e.key}}const[h,m]=await Promise.all([this.ensureSigner(),this.getEntropy(r)]),y=await h.create({accountType:e.accountType,chainType:e.chainType,chainId:e.chainId,entropy:m}),g={id:y.id,chainId:y.chainId,user:o.player,address:y.address,ownerAddress:y.ownerAddress,chainType:y.chainType,accountType:y.accountType,implementationType:y.implementationType,factoryAddress:y.factoryAddress,salt:y.salt,createdAt:y.createdAt,implementationAddress:y.implementationAddress,recoveryMethod:s.parseRecoveryMethod(y.recoveryMethod),recoveryMethodDetails:y.recoveryMethodDetails};return this.eventEmitter.emit(d.ON_EMBEDDED_WALLET_CREATED,g),g}async recover(e){await this.validateAndRefreshToken();const t=e.recoveryParams??{recoveryMethod:c.AUTOMATIC};if(t.recoveryMethod===c.PASSKEY){if(!t.passkeyInfo?.passkeyId)throw new i("Passkey ID must be provided for passkey recovery",n.INVALID_CONFIGURATION);t.passkeyInfo={passkeyId:t.passkeyInfo.passkeyId}}const[r,a]=await Promise.all([this.ensureSigner(),this.getEntropy(t)]),o=await r.recover({account:e.account,entropy:a}),h={id:o.id,chainId:o.chainId,implementationAddress:o.implementationAddress,factoryAddress:o.factoryAddress,salt:o.salt,user:o.user,address:o.address,ownerAddress:o.ownerAddress,chainType:o.chainType,accountType:o.accountType,implementationType:o.implementationType,createdAt:o.createdAt,recoveryMethod:s.parseRecoveryMethod(o.recoveryMethod),recoveryMethodDetails:o.recoveryMethodDetails};return this.eventEmitter.emit(d.ON_EMBEDDED_WALLET_RECOVERED,h),h}async signMessage(e,t){await this.validateAndRefreshToken();const r=await this.ensureSigner(),{hashMessage:a=!0,arrayifyMessage:i=!1}=t||{},n=await s.fromStorage(this.storage);return await r.sign(e,i,a,n?.chainType)}async signTypedData(e,t,r){await this.validateAndRefreshToken();const a=await this.ensureSigner(),o=await s.fromStorage(this.storage);if(!o)throw new i("No account found",n.MISSING_SIGNER_ERROR);const d={...t};delete d.EIP712Domain;const{_TypedDataEncoder:c}=await import("@ethersproject/hash"),h=c.hash(e,d,r);return await u({hash:h,implementationType:o.implementationType||o.type,chainId:Number(o.chainId),signer:a,address:o.address,ownerAddress:o.ownerAddress,factoryAddress:o.factoryAddress,salt:o.salt})}async exportPrivateKey(){await this.validateAndRefreshToken();const e=await this.ensureSigner();return await e.export()}async setRecoveryMethod(e,r){await this.validateAndRefreshToken();const o=await this.ensureSigner(),d=await a.fromStorage(this.storage);if(!d)throw new i("missing authentication",n.AUTHENTICATION_ERROR);let h,m,y,g;if(e.recoveryMethod===c.PASSKEY){const e=await s.fromStorage(this.storage);if(!e)throw new i("missing account",n.INVALID_CONFIGURATION);const t=e?.recoveryMethodDetails?.passkeyId;if(!t)throw new i("missing passkey id for account",n.INVALID_CONFIGURATION);y={passkeyId:t,passkeyKey:await this.passkeyHandler.deriveAndExportKey({id:t,seed:d.player})}}else if(r.recoveryMethod===c.PASSKEY){const e=await this.passkeyHandler.createPasskey({id:t.randomPasskeyName(),displayName:"Openfort - Embedded Wallet",seed:d.player});y={passkeyId:e.id,passkeyKey:e.key},g={passkeyId:e.id}}if(e.recoveryMethod===c.PASSWORD?h=e.password:r.recoveryMethod===c.PASSWORD&&(h=r.password),e.recoveryMethod===c.AUTOMATIC?m=e.encryptionSession:r.recoveryMethod===c.AUTOMATIC&&(m=r.encryptionSession),!h&&!m)throw new i("Password or encryption session is not provided",n.INVALID_CONFIGURATION);await o.setRecoveryMethod({recoveryMethod:r.recoveryMethod,recoveryPassword:h,encryptionSession:m,passkeyInfo:y});const l=await s.fromStorage(this.storage);l&&new s({...l,recoveryMethod:r.recoveryMethod,recoveryMethodDetails:g}).save(this.storage)}async get(){const e=await s.fromStorage(this.storage);if(!e)throw new i("No signer configured",n.MISSING_SIGNER_ERROR);const t=await a.fromStorage(this.storage);if(!t)throw new i("No access token found",n.NOT_LOGGED_IN_ERROR);return{id:e.id,chainId:e.chainId,user:t.player,address:e.address,ownerAddress:e.ownerAddress,factoryAddress:e.factoryAddress,salt:e.salt,chainType:e.chainType,accountType:e.accountType,implementationAddress:e.implementationAddress,implementationType:e.implementationType,createdAt:e.createdAt,recoveryMethod:s.parseRecoveryMethod(e.recoveryMethod),recoveryMethodDetails:e.recoveryMethodDetails}}async list(e){const t={accountType:m.SMART_ACCOUNT,...e},d=r.getInstance();if(!d)throw new i("Configuration not found",n.INVALID_CONFIGURATION);await this.validateAndRefreshToken();const c=await a.fromStorage(this.storage);if(!c)throw new i("No access token found",n.NOT_LOGGED_IN_ERROR);return o(async()=>(await this.backendApiClients.accountsApi.getAccountsV2(t,{headers:{authorization:`Bearer ${d.baseConfiguration.publishableKey}`,"x-player-token":c.token,"x-auth-provider":c.thirdPartyProvider,"x-token-type":c.thirdPartyTokenType}})).data.data.map(e=>({user:e.user,chainType:e.chainType,id:e.id,address:e.address,active:e.smartAccount?.active,ownerAddress:e.ownerAddress,factoryAddress:e.smartAccount?.factoryAddress,salt:e.smartAccount?.salt,accountType:e.accountType,implementationAddress:e.smartAccount?.implementationAddress,createdAt:e.createdAt,implementationType:e.smartAccount?.implementationType,chainId:e.chainId,recoveryMethod:s.parseRecoveryMethod(e.recoveryMethod),recoveryMethodDetails:e.recoveryMethodDetails})),{default:n.AUTHENTICATION_ERROR})}async getEmbeddedState(){try{if(!await a.fromStorage(this.storage))return y.UNAUTHENTICATED;return await s.fromStorage(this.storage)?y.READY:y.EMBEDDED_SIGNER_NOT_CONFIGURED}catch(e){return g("Failed to get embedded state:",e),y.UNAUTHENTICATED}}async getEthereumProvider(e){await this.ensureInitialized();const t={announceProvider:!0,...e},r=await a.fromStorage(this.storage),i=await s.fromStorage(this.storage);return this.provider?this.provider&&t.policy&&this.provider.updatePolicy(t.policy):(this.provider=new p({storage:this.storage,openfortEventEmitter:this.eventEmitter,ensureSigner:this.ensureSigner.bind(this),account:i||void 0,authentication:r||void 0,backendApiClients:this.backendApiClients,policyId:t.policy,validateAndRefreshSession:this.validateAndRefreshToken.bind(this),chains:t.chains}),t.announceProvider&&f({info:{...A,...t.providerInfo},provider:this.provider})),this.provider}async ping(e){try{e>0&&await new Promise(t=>{setTimeout(t,e)});const t=await this.getIframeManager();if(!t.isLoaded())return!1;const r=await a.fromStorage(this.storage);if(r)try{return await t.getCurrentDevice(r.player),!0}catch(e){return!1}return t.isLoaded()}catch(e){return g("Ping failed:",e),!1}}getURL(){const e=r.getInstance();if(!e)throw new i("Configuration not found",n.INVALID_CONFIGURATION);return e.iframeUrl}async setMessagePoster(e){if(!e||"function"!=typeof e.postMessage)throw new i("Invalid message poster",n.INVALID_CONFIGURATION);this.messagePoster=e,this.messenger&&this.messenger.destroy(),this.iframeManager&&this.iframeManager.destroy(),this.signer=null,this.signerPromise=null,this.iframeManager=null,this.iframeManagerPromise=null,this.messenger=null}async handleLogout(){const e=await this.ensureSigner();await e.disconnect(),this.provider=null,this.messenger=null,this.iframeManager=null,this.iframeManagerPromise=null,this.signer=null,this.signerPromise=null}async onMessage(e){if(!e||"object"!=typeof e)return void g("Invalid message received:",e);g("[HANDSHAKE DEBUG] EmbeddedWalletApi onMessage:",e);const t="penpal"===e.namespace&&"SYN"===e.type||e.penpal&&"string"==typeof e.penpal;if(t&&this.messenger&&this.messagePoster)return g("[HANDSHAKE DEBUG] Passing message directly to existing ReactNativeMessenger"),void this.messenger.handleMessage(e);const r=await this.getIframeManager();g(`[HANDSHAKE DEBUG] IframeManager obtained, isLoaded: ${r.isLoaded()}`),t&&!r.isLoaded()&&g("[HANDSHAKE DEBUG] Received penpal message before connection initialized, setting up connection..."),g("[HANDSHAKE DEBUG] Calling iframeManager.onMessage"),await r.onMessage(e),g("[HANDSHAKE DEBUG] iframeManager.onMessage completed")}isReady(){return this.iframeManager?.isLoaded()||!1}}export{M as EmbeddedWalletApi};
