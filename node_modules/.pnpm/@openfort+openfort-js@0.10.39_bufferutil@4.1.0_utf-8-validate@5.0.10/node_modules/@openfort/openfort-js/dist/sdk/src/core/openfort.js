import{BackendApiClients as t}from"../../../packages/internal/openapi-clients/dist/index.js";import{AuthApi as e}from"../api/auth.js";import{EmbeddedWalletApi as i}from"../api/embeddedWallet.js";import{ProxyApi as n}from"../api/proxy.js";import{UserApi as a}from"../api/user.js";import{AuthManager as s}from"../auth/authManager.js";import{StorageKeys as r}from"../storage/istorage.js";import{LazyStorage as o}from"../storage/lazyStorage.js";import h from"../utils/typedEventEmitter.js";import{SDKConfiguration as l}from"./config/config.js";import{PasskeyHandler as c}from"./configuration/passkey.js";import{OpenfortError as d,OpenfortErrorType as u}from"./errors/openfortError.js";import{InternalSentry as g}from"./errors/sentry.js";import{OpenfortInternal as I}from"./openfortInternal.js";class m{storage;iAuthManager=null;openfortInternal;initPromise;asyncInitPromise=null;authInstance;embeddedWalletInstance;userInstance;proxyInstance;configuration;eventEmitter;iPasskeyHandler;static globalEventEmitter=null;get auth(){if(!this.authInstance)throw new d("Openfort SDK not initialized. Please await waitForInitialization() before accessing auth.",u.INVALID_CONFIGURATION);return this.authInstance}get embeddedWallet(){if(!this.embeddedWalletInstance)throw new d("Openfort SDK not initialized. Please await waitForInitialization() before accessing embeddedWallet.",u.INVALID_CONFIGURATION);return this.embeddedWalletInstance}get user(){if(!this.userInstance)throw new d("Openfort SDK not initialized. Please await waitForInitialization() before accessing user.",u.INVALID_CONFIGURATION);return this.userInstance}get proxy(){if(!this.proxyInstance)throw new d("Openfort SDK not initialized. Please await waitForInitialization() before accessing proxy.",u.INVALID_CONFIGURATION);return this.proxyInstance}initializeSynchronously(){try{this.iAuthManager=new s(this.storage),this.openfortInternal=new I(this.storage,this.authManager,this.eventEmitter),this.authInstance=new e(this.storage,this.authManager,this.validateAndRefreshToken.bind(this),this.ensureInitialized.bind(this),this.eventEmitter),this.embeddedWalletInstance=new i(this.storage,this.validateAndRefreshToken.bind(this),this.ensureInitialized.bind(this),this.eventEmitter,this.passkeyHandler),this.userInstance=new a(this.storage,this.authManager,this.validateAndRefreshToken.bind(this)),this.proxyInstance=new n(this.storage,this.backendApiClients,this.validateAndRefreshToken.bind(this),this.ensureInitialized.bind(this),async()=>{if(!this.embeddedWalletInstance)throw new d("Embedded wallet not initialized",u.MISSING_SIGNER_ERROR);const t=this.embeddedWalletInstance;return e=>t.signMessage(e,{hashMessage:!0,arrayifyMessage:!0})})}catch(t){throw new d("Openfort SDK synchronous initialization failed",u.INVALID_CONFIGURATION)}}constructor(t){if(this.configuration=new l(t),this.storage=new o(this.configuration.baseConfiguration.publishableKey,this.configuration.storage),this.eventEmitter=new h,m.globalEventEmitter){["onAuthInit","onAuthSuccess","onAuthFailure","onLogout","onSwitchAccount","onSignedMessage","onEmbeddedWalletCreated","onEmbeddedWalletRecovered","onAuthFlowOpen","onAuthFlowClose","onAuthFlowCancel"].forEach(t=>{this.eventEmitter.on(t,(...e)=>{m.globalEventEmitter?.emit(t,...e)})})}else m.globalEventEmitter=this.eventEmitter;this.iPasskeyHandler=new c({rpId:this.configuration.passkeyRpId,rpName:this.configuration.passkeyRpName,extractableKey:!0}),g.init({configuration:this.configuration}),this.initializeSynchronously(),this.initPromise=Promise.resolve()}static getEventEmitter(){return m.globalEventEmitter||(m.globalEventEmitter=new h),m.globalEventEmitter}async waitForInitialization(){await this.initPromise,await this.ensureAsyncInitialized()}async getAccessToken(){return await this.ensureInitialized(),this.openfortInternal.getAccessToken()}async validateAndRefreshToken(t){return await this.ensureInitialized(),await this.openfortInternal.validateAndRefreshToken(t)}get backendApiClients(){return new t({basePath:this.configuration.backendUrl,accessToken:this.configuration.baseConfiguration.publishableKey,nativeAppIdentifier:this.configuration.nativeAppIdentifier,storage:this.storage,onLogout:()=>{this.eventEmitter.emit("onLogout")}})}get authManager(){if(!this.iAuthManager)throw new d("AuthManager not initialized",u.INTERNAL_ERROR);return this.iAuthManager}get passkeyHandler(){return this.iPasskeyHandler}static async isStorageAccessible(t){try{const e=r.TEST,i="openfort_storage_test";t.save(e,i);const n=await t.get(e);return t.remove(e),n===i}catch(t){return!1}}async initializeAsync(){if(!await m.isStorageAccessible(this.storage))throw new d("Storage is not accessible",u.INVALID_CONFIGURATION);this.authManager.setBackendApiClients(this.backendApiClients,this.configuration.baseConfiguration.publishableKey)}async ensureAsyncInitialized(){this.asyncInitPromise||(this.asyncInitPromise=this.initializeAsync()),await this.asyncInitPromise}async ensureInitialized(){await this.initPromise,await this.ensureAsyncInitialized()}}export{m as Openfort};
