import{withOpenfortError as e,OpenfortErrorType as t}from"../../core/errors/openfortError.js";import{AccountType as n}from"../../types/types.js";import{JsonRpcError as a,RpcErrorCode as s}from"./JsonRpcError.js";const i=async({params:i,signer:o,account:r,authentication:c,backendClient:p,policyId:d})=>{const y=i[0];if(!y.permissionContext)return await o.disconnect(),{};const l=await(async(n,a,s,i,o)=>{const r=((e,t,n,a,s)=>{const i={address:e,chainId:t,player:n,account:s};return a&&(i.policy=a),i})(n.permissionContext,s.chainId,i.player,o,s.id);return e(async()=>(await a.sessionsApi.revokeSession({revokeSessionRequest:r},{headers:{authorization:`Bearer ${a.config.backend.accessToken}`,"x-player-token":i.token,"x-auth-provider":i.thirdPartyProvider,"x-token-type":i.thirdPartyTokenType}})).data,{default:t.AUTHENTICATION_ERROR})})(y,p,r,c,d).catch(e=>{throw new a(s.TRANSACTION_REJECTED,e.message)});if(l?.nextAction?.payload?.signableHash){let e;e=[300,324].includes(r.chainId)||r.implementationType&&[n.CALIBUR].includes(r.implementationType)?await o.sign(l.nextAction.payload.signableHash,!1,!1):await o.sign(l.nextAction.payload.signableHash);return(await p.sessionsApi.signatureSession({id:l.id,signatureRequest:{signature:e}}).catch(e=>{throw new a(s.TRANSACTION_REJECTED,e.message)})).data}return l};export{i as revokeSession};
