"use strict";var e=require("../../core/configuration/account.js"),t=require("../../core/configuration/authentication.js"),r=require("../../types/types.js"),a=require("../../utils/chains/index.js"),s=require("../../utils/crypto.js"),i=require("../../utils/typedEventEmitter.js"),o=require("./addEthereumChain.js"),n=require("./estimateGas.js"),c=require("./getAssets.js"),h=require("./getCallsStatus.js"),d=require("./JsonRpcError.js"),u=require("./personalSign.js"),p=require("./registerSession.js"),l=require("./revokeSession.js"),w=require("./sendCallSync.js"),g=require("./sendCalls.js"),m=require("./signTypedDataV4.js"),E=require("./types.js"),A=require("./walletHelpers.js");exports.EvmProvider=class{#e;#t;#r;#a;updatePolicy(e){this.#t=e}#s;#i;#o=null;#n;isOpenfort=!0;#c;constructor({storage:e,backendApiClients:t,openfortEventEmitter:a,policyId:s,ensureSigner:o,chains:n,validateAndRefreshSession:c}){this.#c=o,this.#e=e,this.#r=n,this.#t=s,this.#s=c,this.#n=t,this.#i=new i,a.on(r.OpenfortEvents.ON_LOGOUT,this.#h),a.on(r.OpenfortEvents.ON_SWITCH_ACCOUNT,this.#d)}#u=async()=>(this.#a||(this.#a=await this.#c()),this.#a);#h=async()=>{this.#a=void 0,this.#i.emit(E.ProviderEvent.ACCOUNTS_CHANGED,[])};#d=async e=>{this.#i.emit(E.ProviderEvent.ACCOUNTS_CHANGED,[e])};async getRpcProvider(){if(!this.#o){const t=await e.Account.fromStorage(this.#e),r=t?.chainId||8453;await import("@ethersproject/providers").then(e=>{const t=this.#r?this.#r[r]:void 0;this.#o=new e.StaticJsonRpcProvider(t??a.defaultChainRpcs[r])})}if(!this.#o)throw new Error("RPC provider not initialized");return this.#o}async#p(i){switch(i.method){case"eth_accounts":{const t=await e.Account.fromStorage(this.#e);return t?[t.address]:[]}case"eth_requestAccounts":{const t=await e.Account.fromStorage(this.#e);if(t)return this.#i.emit(E.ProviderEvent.ACCOUNTS_CONNECT,{chainId:String(t.chainId)}),[t.address];throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - must be authenticated and configured with a signer.")}case"eth_signTransaction":{const r=await e.Account.fromStorage(this.#e),a=await this.#u(),s=await t.Authentication.fromStorage(this.#e);if(!r||!s)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");const o=await this.getRpcProvider(),{chainId:n}=await o.detectNetwork(),[c]=i.params||[];c.chainId||(c.chainId=n.toString());const h=A.parseTransactionRequest(c),{serialize:u}=await import("@ethersproject/transactions"),p=e=>({legacy:0,eip2930:1,eip1559:2}[e]),{gas:l,...w}=h,g={...w,gasLimit:l,to:h.to??void 0,type:p(h.type)},m=u(g),{keccak256:E}=await import("@ethersproject/keccak256"),R=E(m);await this.#s();const f=await a.sign(R,!1,!1),{splitSignature:v}=await import("@ethersproject/bytes");return u(g,v(f))}case"eth_sendTransaction":{const[a,s,o]=await Promise.all([e.Account.fromStorage(this.#e),this.#u(),t.Authentication.fromStorage(this.#e)]);if(!a||!o)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");if(await this.#s(),a?.accountType===r.AccountTypeEnum.EOA){const[e]=i.params||[],t=await this.getRpcProvider(),r=await A.prepareEOATransaction(e,t,a.address),s=await this.#p({method:"eth_signTransaction",params:[r]});return this.#p({method:"eth_sendRawTransaction",params:[s]})}return(await w.sendCallsSync({params:i.params||[],signer:s,account:a,authentication:o,backendClient:this.#n,rpcProvider:await this.getRpcProvider(),policyId:this.#t})).receipt.transactionHash}case"eth_sendRawTransactionSync":{const[a,s,o]=await Promise.all([e.Account.fromStorage(this.#e),this.#u(),t.Authentication.fromStorage(this.#e)]);if(!a||!o)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");if(a?.accountType===r.AccountTypeEnum.EOA)throw new d.JsonRpcError(d.ProviderErrorCode.UNSUPPORTED_METHOD,`${i.method}: Method not supported`);return await this.#s(),await w.sendCallsSync({params:i.params||[],signer:s,account:a,authentication:o,backendClient:this.#n,rpcProvider:await this.getRpcProvider(),policyId:this.#t})}case"eth_estimateGas":{const r=await e.Account.fromStorage(this.#e),a=await t.Authentication.fromStorage(this.#e);if(!r||!a)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await n.estimateGas({params:i.params||[],account:r,authentication:a,backendClient:this.#n,policyId:this.#t})}case"eth_signTypedData":case"eth_signTypedData_v4":{const t=await e.Account.fromStorage(this.#e),r=await this.#u();if(!t)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");await this.#s();const a=await this.getRpcProvider();return await m.signTypedDataV4({method:i.method,params:i.params||[],signer:r,implementationType:t.implementationType||t.type,rpcProvider:a,account:t})}case"personal_sign":{const t=await e.Account.fromStorage(this.#e);if(!t)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");const r=await this.#u();return await this.#s(),await u.personalSign({params:i.params||[],signer:r,account:t})}case"eth_chainId":{const e=await this.getRpcProvider(),{chainId:t}=await e.detectNetwork();return s.numberToHex(t)}case"wallet_switchEthereumChain":{const e=await this.#u();if(!i.params||!Array.isArray(i.params)||0===i.params.length)throw new d.JsonRpcError(d.RpcErrorCode.INVALID_PARAMS,"Invalid parameters for wallet_switchEthereumChain");await this.#s();try{const t=parseInt(i.params[0].chainId,16);await e.switchChain({chainId:t}),await import("@ethersproject/providers").then(e=>{const r=this.#r?this.#r[t]:void 0;this.#o=new e.StaticJsonRpcProvider(r??a.defaultChainRpcs[t])})}catch(e){const t=e;throw new d.JsonRpcError(d.RpcErrorCode.INTERNAL_ERROR,`Failed to switch chain: ${t.message}`)}return null}case"wallet_addEthereumChain":{await this.#u();const e=await this.getRpcProvider();return await o.addEthereumChain({params:i.params||[],rpcProvider:e,storage:this.#e})}case"wallet_showCallsStatus":return null;case"wallet_getCallsStatus":{const a=await e.Account.fromStorage(this.#e);if(a?.accountType===r.AccountTypeEnum.EOA)throw new d.JsonRpcError(d.ProviderErrorCode.UNSUPPORTED_METHOD,`${i.method}: Method not supported`);const s=await t.Authentication.fromStorage(this.#e);if(!a||!s)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await h.getCallStatus({params:i.params||{},authentication:s,backendClient:this.#n})}case"wallet_sendCalls":{const[a,s,o]=await Promise.all([e.Account.fromStorage(this.#e),this.#u(),t.Authentication.fromStorage(this.#e)]);if(a?.accountType===r.AccountTypeEnum.EOA)throw new d.JsonRpcError(d.ProviderErrorCode.UNSUPPORTED_METHOD,`${i.method}: Method not supported`);if(!a||!o)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");await this.#s();return await g.sendCalls({params:i.params?i.params[0].calls:[],signer:s,account:a,authentication:o,backendClient:this.#n,rpcProvider:await this.getRpcProvider(),policyId:this.#t})}case"wallet_grantPermissions":{const a=await e.Account.fromStorage(this.#e);if(a?.accountType===r.AccountTypeEnum.EOA)throw new d.JsonRpcError(d.ProviderErrorCode.UNSUPPORTED_METHOD,`${i.method}: Method not supported`);const s=await this.#u(),o=await t.Authentication.fromStorage(this.#e);if(!a||!o)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await p.registerSession({params:i.params||[],signer:s,account:a,authentication:o,backendClient:this.#n,policyId:this.#t})}case"wallet_revokePermissions":{const r=await e.Account.fromStorage(this.#e),a=await this.#u(),s=await t.Authentication.fromStorage(this.#e);if(!r||!s)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await l.revokeSession({params:i.params||[],signer:a,account:r,authentication:s,backendClient:this.#n,policyId:this.#t})}case"wallet_getCapabilities":{const t=await e.Account.fromStorage(this.#e);if(t?.accountType===r.AccountTypeEnum.EOA)throw new d.JsonRpcError(d.ProviderErrorCode.UNSUPPORTED_METHOD,`${i.method}: Method not supported`);const a=await this.getRpcProvider(),{chainId:o}=await a.detectNetwork();return{[s.numberToHex(o)]:{permissions:{supported:!0,signerTypes:["account","key"],keyTypes:["secp256k1"],permissionTypes:["contract-calls"]},paymasterService:{supported:!0},atomicBatch:{supported:!0}}}}case"wallet_getAssets":{const r=await e.Account.fromStorage(this.#e),a=await t.Authentication.fromStorage(this.#e);if(!r||!a)throw new d.JsonRpcError(d.ProviderErrorCode.UNAUTHORIZED,"Unauthorized - call eth_requestAccounts first");return await this.#s(),await c.getAssets({params:i.params?.[0],account:r,authentication:a,backendClient:this.#n})}case"eth_gasPrice":case"eth_getBalance":case"eth_sendRawTransaction":case"eth_getCode":case"eth_getStorageAt":case"eth_call":case"eth_blockNumber":case"eth_getBlockByHash":case"eth_getBlockByNumber":case"eth_getTransactionByHash":case"eth_getTransactionReceipt":case"eth_getTransactionCount":return(await this.getRpcProvider()).send(i.method,i.params||[]);default:throw new d.JsonRpcError(d.ProviderErrorCode.UNSUPPORTED_METHOD,`${i.method}: Method not supported`)}}async request(e){try{return this.#p(e)}catch(e){if(e instanceof d.JsonRpcError)throw e;if(e instanceof Error)throw new d.JsonRpcError(d.RpcErrorCode.INTERNAL_ERROR,e.message);throw new d.JsonRpcError(d.RpcErrorCode.INTERNAL_ERROR,"Internal error")}}on(e,t){this.#i.on(e,t)}removeListener(e,t){this.#i.off(e,t)}};
