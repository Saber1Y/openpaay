"use strict";var e=require("../../core/errors/openfortError.js"),r=require("../../types/types.js"),n=require("./JsonRpcError.js");exports.revokeSession=async({params:t,signer:s,account:a,authentication:o,backendClient:i,policyId:c})=>{const p=t[0];if(!p.permissionContext)return await s.disconnect(),{};const d=await(async(r,n,t,s,a)=>{const o=((e,r,n,t,s)=>{const a={address:e,chainId:r,player:n,account:s};return t&&(a.policy=t),a})(r.permissionContext,t.chainId,s.player,a,t.id);return e.withOpenfortError(async()=>(await n.sessionsApi.revokeSession({revokeSessionRequest:o},{headers:{authorization:`Bearer ${n.config.backend.accessToken}`,"x-player-token":s.token,"x-auth-provider":s.thirdPartyProvider,"x-token-type":s.thirdPartyTokenType}})).data,{default:e.OpenfortErrorType.AUTHENTICATION_ERROR})})(p,i,a,o,c).catch(e=>{throw new n.JsonRpcError(n.RpcErrorCode.TRANSACTION_REJECTED,e.message)});if(d?.nextAction?.payload?.signableHash){let e;e=[300,324].includes(a.chainId)||a.implementationType&&[r.AccountType.CALIBUR].includes(a.implementationType)?await s.sign(d.nextAction.payload.signableHash,!1,!1):await s.sign(d.nextAction.payload.signableHash);return(await i.sessionsApi.signatureSession({id:d.id,signatureRequest:{signature:e}}).catch(e=>{throw new n.JsonRpcError(n.RpcErrorCode.TRANSACTION_REJECTED,e.message)})).data}return d};
