"use strict";var e=require("../core/configuration/authentication.js"),t=require("../core/configuration/passkey.js"),a=require("../core/errors/openfortError.js"),r=require("../core/config/config.js"),o=require("../core/configuration/account.js"),n=require("../storage/istorage.js"),s=require("../types/types.js");exports.EmbeddedSigner=class{iframeManager;storage;backendApiClients;passkeyHandler;eventEmitter;constructor(e,t,a,r,o){this.iframeManager=e,this.storage=t,this.backendApiClients=a,this.passkeyHandler=r,this.eventEmitter=o}async createPasskey(e){const a=await this.passkeyHandler.createPasskey({id:t.PasskeyHandler.randomPasskeyName(),displayName:"Openfort - Embedded Wallet",seed:e});return{id:a.id,key:a.key}}async configure(t){const n=await e.Authentication.fromStorage(this.storage);if(!n)throw new a.OpenfortError("No access token found",a.OpenfortErrorType.NOT_LOGGED_IN_ERROR);const i=r.SDKConfiguration.getInstance();if(!i)throw new a.OpenfortError("Configuration not found",a.OpenfortErrorType.INVALID_CONFIGURATION);const c=await o.Account.fromStorage(this.storage);let d;if(c){const e={account:c.id,...t.entropy&&{entropy:{...t.entropy.recoveryPassword&&{recoveryPassword:t.entropy.recoveryPassword},...t.entropy.encryptionSession&&{encryptionSession:t.entropy.encryptionSession},..."passkey"===c.recoveryMethod&&{passkey:{id:c.recoveryMethodDetails?.passkeyId,env:c.recoveryMethodDetails?.passkeyEnv,key:await t.getPasskeyKeyFn(c.recoveryMethodDetails?.passkeyId??"")}}}}},a=await this.iframeManager.recover(e);d=a.account}else{const e=await this.backendApiClients.accountsApi.getAccountsV2({user:n.player,accountType:t.accountType,chainType:t.chainType},{headers:{authorization:`Bearer ${i.baseConfiguration.publishableKey}`,"x-player-token":n.token,"x-auth-provider":n.thirdPartyProvider,"x-token-type":n.thirdPartyTokenType}});if(0===e.data.data.length){const e=t.entropy?.passkey?await this.createPasskey(n.player):void 0,a={accountType:t.accountType,chainType:t.chainType,chainId:t.chainId,...t.entropy&&{entropy:{...t.entropy.recoveryPassword&&{recoveryPassword:t.entropy.recoveryPassword},...t.entropy.encryptionSession&&{encryptionSession:t.entropy.encryptionSession},...t.entropy.passkey&&{passkey:e}}}},r=await this.iframeManager.create(a);d=r.account}else{const a=e.data.data,r=a.find(e=>e.chainId===t.chainId),o=r||a[0],n={account:o.id,...t.entropy&&{entropy:{...t.entropy.recoveryPassword&&{recoveryPassword:t.entropy.recoveryPassword},...t.entropy.encryptionSession&&{encryptionSession:t.entropy.encryptionSession},..."passkey"===o.recoveryMethod&&{passkey:{id:o.recoveryMethodDetails?.passkeyId,env:o.recoveryMethodDetails?.passkeyEnv,key:await t.getPasskeyKeyFn(o.recoveryMethodDetails?.passkeyId??"")}}}}},s=await this.iframeManager.recover(n);if(d=s.account,!r){const e=await this.iframeManager.switchChain(t.chainId);d=e.account}}}return a.withOpenfortError(async()=>{const e=await this.backendApiClients.accountsApi.getAccountV2({id:d},{headers:{authorization:`Bearer ${i.baseConfiguration.publishableKey}`,"x-player-token":n.token,"x-auth-provider":n.thirdPartyProvider,"x-token-type":n.thirdPartyTokenType}}),t=new o.Account({user:e.data.user,chainType:e.data.chainType,id:e.data.id,address:e.data.address,ownerAddress:e.data.ownerAddress,accountType:e.data.accountType,createdAt:e.data.createdAt,implementationAddress:e.data.smartAccount?.implementationAddress,implementationType:e.data.smartAccount?.implementationType,chainId:e.data.chainId,salt:e.data.smartAccount?.salt,factoryAddress:e.data.smartAccount?.factoryAddress,recoveryMethod:o.Account.parseRecoveryMethod(e.data.recoveryMethod),recoveryMethodDetails:e.data.recoveryMethodDetails});return t.save(this.storage),this.eventEmitter.emit(s.OpenfortEvents.ON_SWITCH_ACCOUNT,e.data.address),t},{default:a.OpenfortErrorType.AUTHENTICATION_ERROR})}async sign(e,t,a,r){const o=await this.iframeManager.sign(e,t,a,r);return this.eventEmitter.emit(s.OpenfortEvents.ON_SIGNED_MESSAGE,{message:e,signature:o}),o}async export(){return await this.iframeManager.export()}async switchChain({chainId:e}){const t=await o.Account.fromStorage(this.storage);if(t?.accountType===s.AccountTypeEnum.EOA)new o.Account({...t,chainId:e}).save(this.storage);else{const a=await this.iframeManager.switchChain(e);new o.Account({...t,id:a.account,chainId:e}).save(this.storage)}}async create(t){const n=await this.iframeManager.create(t),i=await e.Authentication.fromStorage(this.storage);if(!i)throw new a.OpenfortError("No access token found",a.OpenfortErrorType.NOT_LOGGED_IN_ERROR);const c=r.SDKConfiguration.getInstance();if(!c)throw new a.OpenfortError("Configuration not found",a.OpenfortErrorType.INVALID_CONFIGURATION);return a.withOpenfortError(async()=>{const e=await this.backendApiClients.accountsApi.getAccountV2({id:n.account},{headers:{authorization:`Bearer ${c.baseConfiguration.publishableKey}`,"x-player-token":i.token,"x-auth-provider":i.thirdPartyProvider,"x-token-type":i.thirdPartyTokenType}}),t=new o.Account({user:e.data.user,chainType:e.data.chainType,id:e.data.id,address:e.data.address,ownerAddress:e.data.ownerAddress,accountType:e.data.accountType,createdAt:e.data.createdAt,implementationType:e.data.smartAccount?.implementationType,chainId:e.data.chainId,implementationAddress:e.data.smartAccount?.implementationAddress,salt:e.data.smartAccount?.salt,factoryAddress:e.data.smartAccount?.factoryAddress,recoveryMethod:o.Account.parseRecoveryMethod(e.data.recoveryMethod),recoveryMethodDetails:e.data.recoveryMethodDetails});return t.save(this.storage),this.eventEmitter.emit(s.OpenfortEvents.ON_SWITCH_ACCOUNT,e.data.address),t},{default:a.OpenfortErrorType.AUTHENTICATION_ERROR})}async recover(t){const n=await this.iframeManager.recover(t),i=await e.Authentication.fromStorage(this.storage);if(!i)throw new a.OpenfortError("No access token found",a.OpenfortErrorType.NOT_LOGGED_IN_ERROR);const c=r.SDKConfiguration.getInstance();if(!c)throw new a.OpenfortError("Configuration not found",a.OpenfortErrorType.INVALID_CONFIGURATION);return a.withOpenfortError(async()=>{const e=await this.backendApiClients.accountsApi.getAccountV2({id:n.account},{headers:{authorization:`Bearer ${c.baseConfiguration.publishableKey}`,"x-player-token":i.token,"x-auth-provider":i.thirdPartyProvider,"x-token-type":i.thirdPartyTokenType}}),t=new o.Account({user:e.data.user,chainType:e.data.chainType,id:e.data.id,address:e.data.address,ownerAddress:e.data.ownerAddress,accountType:e.data.accountType,createdAt:e.data.createdAt,implementationAddress:e.data.smartAccount?.implementationAddress,implementationType:e.data.smartAccount?.implementationType,chainId:e.data.chainId,salt:e.data.smartAccount?.salt,factoryAddress:e.data.smartAccount?.factoryAddress,recoveryMethod:o.Account.parseRecoveryMethod(e.data.recoveryMethod),recoveryMethodDetails:e.data.recoveryMethodDetails});return t.save(this.storage),this.eventEmitter.emit(s.OpenfortEvents.ON_SWITCH_ACCOUNT,e.data.address),t},{default:a.OpenfortErrorType.AUTHENTICATION_ERROR})}async setRecoveryMethod({recoveryMethod:e,recoveryPassword:t,encryptionSession:a,passkeyInfo:r}){await this.iframeManager.setRecoveryMethod(e,t,a,r?.passkeyKey,r?.passkeyId)}async disconnect(){await this.iframeManager.disconnect(),this.storage.remove(n.StorageKeys.ACCOUNT)}};
