"use strict";var e=require("../core/configuration/account.js"),r=require("../core/configuration/authentication.js"),i=require("../core/errors/openfortError.js"),t=require("../core/errors/sentry.js"),n=require("../storage/istorage.js"),o=require("../utils/crypto.js"),s=require("../utils/debug.js"),a=require("./messaging/ReactNativeMessenger.js"),d=require("./messaging/browserMessenger/connect.js");require("./messaging/browserMessenger/backwardCompatibility.js");var c=require("./types.js");class u extends Error{constructor(){super("This embedded signer requires a password to be recovered")}}class h extends Error{constructor(){super("Wrong recovery passkey for this embedded signer")}}class g extends Error{constructor(){super("MissingProjectEntropyError")}}class l extends Error{constructor(){super("Wrong recovery password for this embedded signer")}}class y extends Error{constructor(){super("Not configured")}}class p extends Error{constructor(){super("OTP required")}}exports.IframeManager=class{messenger;connection;remote;storage;sdkConfiguration;isInitialized=!1;initializationPromise=null;hasFailed=!1;constructor(e,r,t){if(!e)throw new i.OpenfortError("Configuration is required for IframeManager",i.OpenfortErrorType.INVALID_CONFIGURATION);if(!r)throw new i.OpenfortError("Storage is required for IframeManager",i.OpenfortErrorType.INVALID_CONFIGURATION);if(!t)throw new i.OpenfortError("Messenger is required for IframeManager",i.OpenfortErrorType.INVALID_CONFIGURATION);this.sdkConfiguration=e,this.storage=r,this.messenger=t}async initialize(){if(!this.isInitialized){if(this.hasFailed)throw new i.OpenfortError("Failed to establish iFrame connection: Previous connection attempt failed",i.OpenfortErrorType.INTERNAL_ERROR);if(this.initializationPromise)await this.initializationPromise;else{this.initializationPromise=this.doInitialize();try{await this.initializationPromise,this.isInitialized=!0}catch(e){throw this.hasFailed=!0,this.initializationPromise=null,e}}}}async doInitialize(){s.debugLog("Initializing IframeManager connection..."),this.messenger.initialize({validateReceivedMessage:e=>!(!e||"object"!=typeof e),log:s.debugLog}),this.connection=d({messenger:this.messenger,timeout:1e4,log:s.debugLog});try{this.remote=await this.connection.promise,s.debugLog("IframeManager connection established")}catch(e){const r=e;throw t.sentry.captureException(r),this.destroy(),s.debugLog("Failed to establish connection:",r),new i.OpenfortError(`Failed to establish iFrame connection: ${r.cause||r.message}`,i.OpenfortErrorType.INTERNAL_ERROR,e)}}async ensureConnection(){if(this.isInitialized&&this.remote||await this.initialize(),!this.remote)throw new i.OpenfortError("Failed to establish connection",i.OpenfortErrorType.INTERNAL_ERROR);return this.remote}handleError(e){if(c.isErrorResponse(e)){if(e.error===c.NOT_CONFIGURED_ERROR)throw this.storage.remove(n.StorageKeys.ACCOUNT),new y;if(e.error===c.MISSING_USER_ENTROPY_ERROR)throw this.storage.remove(n.StorageKeys.ACCOUNT),new u;if(e.error===c.MISSING_PROJECT_ENTROPY_ERROR)throw this.storage.remove(n.StorageKeys.ACCOUNT),new g;if(e.error===c.INCORRECT_USER_ENTROPY_ERROR)throw new l;if(e.error===c.MISSING_PASSKEY_ERROR)throw this.storage.remove(n.StorageKeys.ACCOUNT),new u;if(e.error===c.INCORRECT_PASSKEY_ERROR)throw new h;if(e.error===c.OTP_REQUIRED_ERROR)throw new p;throw this.storage.remove(n.StorageKeys.ACCOUNT),new i.OpenfortError(`Unknown error: ${e.error}`,i.OpenfortErrorType.INTERNAL_ERROR)}throw e}async buildRequestConfiguration(){const e=await r.Authentication.fromStorage(this.storage);if(!e)throw new i.OpenfortError("Must be authenticated to create a signer",i.OpenfortErrorType.NOT_LOGGED_IN_ERROR);const t={auth:c.ShieldAuthType.OPENFORT,authProvider:e.thirdPartyProvider,token:e.token,tokenType:e.thirdPartyTokenType};return{thirdPartyProvider:e.thirdPartyProvider,thirdPartyTokenType:e.thirdPartyTokenType,token:e.token,publishableKey:this.sdkConfiguration.baseConfiguration.publishableKey,openfortURL:this.sdkConfiguration.backendUrl,shieldAuthentication:t,shieldAPIKey:this.sdkConfiguration.shieldConfiguration?.shieldPublishableKey||"",shieldURL:this.sdkConfiguration.shieldUrl,encryptionKey:this.sdkConfiguration?.shieldConfiguration?.shieldEncryptionKey??void 0,appNativeIdentifier:this.sdkConfiguration?.nativeAppIdentifier??void 0}}async buildIFrameRequestConfiguration(){const e=await r.Authentication.fromStorage(this.storage);if(!e)throw new i.OpenfortError("Must be authenticated to create a signer",i.OpenfortErrorType.NOT_LOGGED_IN_ERROR);const t={auth:c.ShieldAuthType.OPENFORT,authProvider:e.thirdPartyProvider,token:e.token,tokenType:e.thirdPartyTokenType};return{thirdPartyTokenType:e.thirdPartyTokenType??null,thirdPartyProvider:e.thirdPartyProvider??null,accessToken:e.token,playerID:e.player,recovery:t,chainId:null,password:null,passkey:null}}async create(e){if(!this.sdkConfiguration.shieldConfiguration)throw new Error("shieldConfiguration is required");const r=await this.ensureConnection(),i=await this.buildIFrameRequestConfiguration();i.chainId=e.chainId??null,i.password=e?.entropy?.recoveryPassword??null,i.recovery={...i.recovery,encryptionSession:e?.entropy?.encryptionSession},i.passkey=e?.entropy?.passkey??null;const t={uuid:o.randomUUID(),action:c.Event.CREATE,recovery:i.recovery,publishableKey:this.sdkConfiguration.baseConfiguration.publishableKey,shieldAPIKey:this.sdkConfiguration.shieldConfiguration?.shieldPublishableKey||"",accessToken:i.accessToken,playerID:i.playerID,thirdPartyProvider:i.thirdPartyProvider,thirdPartyTokenType:i.thirdPartyTokenType,encryptionKey:i.password,encryptionSession:i.recovery?.encryptionSession??null,passkey:i.passkey??null,openfortURL:this.sdkConfiguration.backendUrl,shieldURL:this.sdkConfiguration.shieldUrl,chainId:e.chainId??null,accountType:e.accountType,chainType:e.chainType,nativeAppIdentifier:this.sdkConfiguration?.nativeAppIdentifier??null},n=await r.create(t);return c.isErrorResponse(n)&&this.handleError(n),"undefined"!=typeof sessionStorage&&sessionStorage.setItem("iframe-version",n.version??"undefined"),n}async recover(r){if(!this.sdkConfiguration.shieldConfiguration)throw new Error("shieldConfiguration is required");const i=await e.Account.fromStorage(this.storage),t=await this.ensureConnection(),n=await this.buildIFrameRequestConfiguration();n.chainId=i?.chainId??null,n.password=r?.entropy?.recoveryPassword??null,n.recovery={...n.recovery,encryptionSession:r?.entropy?.encryptionSession},n.passkey=r?.entropy?.passkey??null;const s={uuid:o.randomUUID(),action:c.Event.RECOVER,recovery:n.recovery,publishableKey:this.sdkConfiguration.baseConfiguration.publishableKey,shieldAPIKey:this.sdkConfiguration.shieldConfiguration?.shieldPublishableKey||"",accessToken:n.accessToken,playerID:n.playerID,thirdPartyProvider:n.thirdPartyProvider,thirdPartyTokenType:n.thirdPartyTokenType,encryptionKey:n.password,encryptionSession:n.recovery?.encryptionSession??null,passkey:n.passkey??null,openfortURL:this.sdkConfiguration.backendUrl,shieldURL:this.sdkConfiguration.shieldUrl,account:r.account,nativeAppIdentifier:this.sdkConfiguration?.nativeAppIdentifier??null},a=await t.recover(s);return c.isErrorResponse(a)&&this.handleError(a),"undefined"!=typeof sessionStorage&&sessionStorage.setItem("iframe-version",a.version??"undefined"),a}async sign(e,r,i,t){s.debugLog("[iframe] ensureConnection");const n=await this.ensureConnection(),a=new c.SignRequest(o.randomUUID(),e,await this.buildRequestConfiguration(),r,i,t);s.debugLog("[iframe] done ensureConnection");const d=await n.sign(a);return s.debugLog("[iframe] response",d),c.isErrorResponse(d)&&this.handleError(d),"undefined"!=typeof sessionStorage&&sessionStorage.setItem("iframe-version",d.version??"undefined"),d.signature}async switchChain(e){const r=await this.ensureConnection(),i=new c.SwitchChainRequest(o.randomUUID(),e,await this.buildRequestConfiguration()),t=await r.switchChain(i);return c.isErrorResponse(t)&&this.handleError(t),t}async export(){const e=await this.ensureConnection(),r=new c.ExportPrivateKeyRequest(o.randomUUID(),await this.buildRequestConfiguration()),i=await e.export(r);return c.isErrorResponse(i)&&this.handleError(i),"undefined"!=typeof sessionStorage&&sessionStorage.setItem("iframe-version",i.version??"undefined"),i.key}async setRecoveryMethod(e,r,i,t,n){const s=await this.ensureConnection(),a=new c.SetRecoveryMethodRequest(o.randomUUID(),e,await this.buildRequestConfiguration(),r,i,t,n),d=await s.setRecoveryMethod(a);c.isErrorResponse(d)&&this.handleError(d),"undefined"!=typeof sessionStorage&&sessionStorage.setItem("iframe-version",d.version??"undefined")}async getCurrentDevice(e){const r=await this.ensureConnection(),i=new c.GetCurrentDeviceRequest(o.randomUUID(),e);try{const e=await r.getCurrentDevice(i);return c.isErrorResponse(e)&&this.handleError(e),"undefined"!=typeof sessionStorage&&sessionStorage.setItem("iframe-version",e.version??"undefined"),e}catch(e){if(e instanceof y)return null;throw e}}async updateAuthentication(){if(!this.isLoaded()||!this.remote)return void s.debugLog("IframeManager not loaded, skipping authentication update");const e=await r.Authentication.fromStorage(this.storage);if(!e)return void s.debugLog("No authentication found, skipping update");const i=new c.UpdateAuthenticationRequest(o.randomUUID(),e.token);s.debugLog("Updating authentication in iframe with token");const t=await this.remote.updateAuthentication(i);c.isErrorResponse(t)&&this.handleError(t)}async disconnect(){const e=await this.ensureConnection(),r={uuid:o.randomUUID()};await e.logout(r)}async onMessage(e){s.debugLog("[HANDSHAKE DEBUG] IframeManager.onMessage called with:",e),this.messenger instanceof a.ReactNativeMessenger?(this.isInitialized||this.connection?s.debugLog(`[HANDSHAKE DEBUG] Connection already initialized (isInitialized: ${this.isInitialized}, hasConnection: ${!!this.connection})`):(s.debugLog("[HANDSHAKE DEBUG] First message received, initializing connection..."),this.initialize().catch(e=>{s.debugLog("[HANDSHAKE DEBUG] Failed to initialize connection:",e)})),s.debugLog("[HANDSHAKE DEBUG] Passing message to ReactNativeMessenger"),this.messenger.handleMessage(e)):s.debugLog("[HANDSHAKE DEBUG] Not a ReactNativeMessenger, ignoring message")}isLoaded(){return this.isInitialized&&void 0!==this.remote}destroy(){this.connection&&this.connection.destroy(),this.remote=void 0,this.isInitialized=!1,this.connection=void 0,this.initializationPromise=null}},exports.MissingProjectEntropyError=g,exports.MissingRecoveryPasswordError=u,exports.NotConfiguredError=y,exports.OTPRequiredError=p,exports.WrongRecoveryPasswordError=l;
