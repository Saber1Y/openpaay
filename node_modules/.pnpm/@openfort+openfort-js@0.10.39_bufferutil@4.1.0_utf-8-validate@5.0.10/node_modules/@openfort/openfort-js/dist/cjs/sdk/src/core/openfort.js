"use strict";var e=require("../../../packages/internal/openapi-clients/dist/index.js"),t=require("../api/auth.js"),i=require("../api/embeddedWallet.js"),n=require("../api/proxy.js"),r=require("../api/user.js"),a=require("../auth/authManager.js"),s=require("../storage/istorage.js"),o=require("../storage/lazyStorage.js"),h=require("../utils/typedEventEmitter.js"),l=require("./config/config.js"),u=require("./configuration/passkey.js"),c=require("./errors/openfortError.js"),d=require("./errors/sentry.js"),g=require("./openfortInternal.js");class p{storage;iAuthManager=null;openfortInternal;initPromise;asyncInitPromise=null;authInstance;embeddedWalletInstance;userInstance;proxyInstance;configuration;eventEmitter;iPasskeyHandler;static globalEventEmitter=null;get auth(){if(!this.authInstance)throw new c.OpenfortError("Openfort SDK not initialized. Please await waitForInitialization() before accessing auth.",c.OpenfortErrorType.INVALID_CONFIGURATION);return this.authInstance}get embeddedWallet(){if(!this.embeddedWalletInstance)throw new c.OpenfortError("Openfort SDK not initialized. Please await waitForInitialization() before accessing embeddedWallet.",c.OpenfortErrorType.INVALID_CONFIGURATION);return this.embeddedWalletInstance}get user(){if(!this.userInstance)throw new c.OpenfortError("Openfort SDK not initialized. Please await waitForInitialization() before accessing user.",c.OpenfortErrorType.INVALID_CONFIGURATION);return this.userInstance}get proxy(){if(!this.proxyInstance)throw new c.OpenfortError("Openfort SDK not initialized. Please await waitForInitialization() before accessing proxy.",c.OpenfortErrorType.INVALID_CONFIGURATION);return this.proxyInstance}initializeSynchronously(){try{this.iAuthManager=new a.AuthManager(this.storage),this.openfortInternal=new g.OpenfortInternal(this.storage,this.authManager,this.eventEmitter),this.authInstance=new t.AuthApi(this.storage,this.authManager,this.validateAndRefreshToken.bind(this),this.ensureInitialized.bind(this),this.eventEmitter),this.embeddedWalletInstance=new i.EmbeddedWalletApi(this.storage,this.validateAndRefreshToken.bind(this),this.ensureInitialized.bind(this),this.eventEmitter,this.passkeyHandler),this.userInstance=new r.UserApi(this.storage,this.authManager,this.validateAndRefreshToken.bind(this)),this.proxyInstance=new n.ProxyApi(this.storage,this.backendApiClients,this.validateAndRefreshToken.bind(this),this.ensureInitialized.bind(this),async()=>{if(!this.embeddedWalletInstance)throw new c.OpenfortError("Embedded wallet not initialized",c.OpenfortErrorType.MISSING_SIGNER_ERROR);const e=this.embeddedWalletInstance;return t=>e.signMessage(t,{hashMessage:!0,arrayifyMessage:!0})})}catch(e){throw new c.OpenfortError("Openfort SDK synchronous initialization failed",c.OpenfortErrorType.INVALID_CONFIGURATION)}}constructor(e){if(this.configuration=new l.SDKConfiguration(e),this.storage=new o.LazyStorage(this.configuration.baseConfiguration.publishableKey,this.configuration.storage),this.eventEmitter=new h,p.globalEventEmitter){["onAuthInit","onAuthSuccess","onAuthFailure","onLogout","onSwitchAccount","onSignedMessage","onEmbeddedWalletCreated","onEmbeddedWalletRecovered","onAuthFlowOpen","onAuthFlowClose","onAuthFlowCancel"].forEach(e=>{this.eventEmitter.on(e,(...t)=>{p.globalEventEmitter?.emit(e,...t)})})}else p.globalEventEmitter=this.eventEmitter;this.iPasskeyHandler=new u.PasskeyHandler({rpId:this.configuration.passkeyRpId,rpName:this.configuration.passkeyRpName,extractableKey:!0}),d.InternalSentry.init({configuration:this.configuration}),this.initializeSynchronously(),this.initPromise=Promise.resolve()}static getEventEmitter(){return p.globalEventEmitter||(p.globalEventEmitter=new h),p.globalEventEmitter}async waitForInitialization(){await this.initPromise,await this.ensureAsyncInitialized()}async getAccessToken(){return await this.ensureInitialized(),this.openfortInternal.getAccessToken()}async validateAndRefreshToken(e){return await this.ensureInitialized(),await this.openfortInternal.validateAndRefreshToken(e)}get backendApiClients(){return new e.BackendApiClients({basePath:this.configuration.backendUrl,accessToken:this.configuration.baseConfiguration.publishableKey,nativeAppIdentifier:this.configuration.nativeAppIdentifier,storage:this.storage,onLogout:()=>{this.eventEmitter.emit("onLogout")}})}get authManager(){if(!this.iAuthManager)throw new c.OpenfortError("AuthManager not initialized",c.OpenfortErrorType.INTERNAL_ERROR);return this.iAuthManager}get passkeyHandler(){return this.iPasskeyHandler}static async isStorageAccessible(e){try{const t=s.StorageKeys.TEST,i="openfort_storage_test";e.save(t,i);const n=await e.get(t);return e.remove(t),n===i}catch(e){return!1}}async initializeAsync(){if(!await p.isStorageAccessible(this.storage))throw new c.OpenfortError("Storage is not accessible",c.OpenfortErrorType.INVALID_CONFIGURATION);this.authManager.setBackendApiClients(this.backendApiClients,this.configuration.baseConfiguration.publishableKey)}async ensureAsyncInitialized(){this.asyncInitPromise||(this.asyncInitPromise=this.initializeAsync()),await this.asyncInitPromise}async ensureInitialized(){await this.initPromise,await this.ensureAsyncInitialized()}}exports.Openfort=p;
