"use strict";var e=require("../../../packages/internal/openapi-clients/dist/index.js"),r=require("../core/configuration/passkey.js"),t=require("../core/config/config.js"),a=require("../core/configuration/account.js"),s=require("../core/configuration/authentication.js"),n=require("../core/errors/openfortError.js"),i=require("../types/types.js"),o=require("../utils/debug.js"),d=require("../wallets/embedded.js"),c=require("../wallets/evm/evmProvider.js");require("../wallets/evm/types.js");var g=require("../wallets/evm/provider/eip6963.js"),h=require("../wallets/evm/walletHelpers.js"),y=require("../wallets/iframeManager.js"),p=require("../wallets/messaging/ReactNativeMessenger.js");require("../wallets/messaging/browserMessenger/backwardCompatibility.js");var u=require("../wallets/messaging/browserMessenger/messengers/WindowMessenger.js");exports.EmbeddedWalletApi=class{storage;validateAndRefreshToken;ensureInitialized;eventEmitter;passkeyHandler;iframeManager=null;iframeManagerPromise=null;signer=null;signerPromise=null;provider=null;messagePoster=null;messenger=null;constructor(e,r,t,a,s){this.storage=e,this.validateAndRefreshToken=r,this.ensureInitialized=t,this.eventEmitter=a,this.passkeyHandler=s,this.eventEmitter.on(i.OpenfortEvents.ON_LOGOUT,()=>{o.debugLog("Handling logout event in EmbeddedWalletApi"),this.handleLogout()})}get backendApiClients(){const r=t.SDKConfiguration.getInstance();if(!r)throw new n.OpenfortError("Configuration not found",n.OpenfortErrorType.INVALID_CONFIGURATION);return new e.BackendApiClients({basePath:r.backendUrl,accessToken:r.baseConfiguration.publishableKey,nativeAppIdentifier:r.nativeAppIdentifier})}async getIframeManager(){if(o.debugLog("[HANDSHAKE DEBUG] getIframeManager called"),this.iframeManager&&this.iframeManager.hasFailed&&(o.debugLog("[HANDSHAKE DEBUG] Existing iframeManager has failed, clearing for recreation"),this.messenger&&(this.messenger.destroy(),this.messenger=null),this.iframeManager=null),this.iframeManager)return o.debugLog("[HANDSHAKE DEBUG] Returning existing iframeManager instance"),this.iframeManager;if(this.iframeManagerPromise)return o.debugLog("[HANDSHAKE DEBUG] Returning existing iframeManagerPromise"),this.iframeManagerPromise;o.debugLog("[HANDSHAKE DEBUG] Creating new iframeManager"),this.iframeManagerPromise=this.createIframeManager();try{return o.debugLog("[HANDSHAKE DEBUG] Awaiting iframeManager creation"),this.iframeManager=await this.iframeManagerPromise,o.debugLog("[HANDSHAKE DEBUG] IframeManager created successfully"),this.iframeManagerPromise=null,this.iframeManager}catch(e){throw o.debugLog("[HANDSHAKE DEBUG] Error creating iframeManager:",e),this.iframeManagerPromise=null,this.messenger&&(this.messenger.destroy(),this.messenger=null),this.iframeManager=null,e}}async createIframeManager(){o.debugLog("[HANDSHAKE DEBUG] createIframeManager starting");const e=t.SDKConfiguration.getInstance();if(!e)throw o.debugLog("[HANDSHAKE DEBUG] Configuration not found"),new n.OpenfortError("Configuration not found",n.OpenfortErrorType.INVALID_CONFIGURATION);let r;if(o.debugLog("[HANDSHAKE DEBUG] Configuration found"),this.messagePoster)o.debugLog("[HANDSHAKE DEBUG] Creating ReactNativeMessenger with messagePoster"),this.messenger&&(o.debugLog("[HANDSHAKE DEBUG] Destroying old messenger before creating new one"),this.messenger.destroy()),this.messenger=new p.ReactNativeMessenger(this.messagePoster),o.debugLog("[HANDSHAKE DEBUG] Created new ReactNativeMessenger instance"),r=this.messenger;else{o.debugLog("[HANDSHAKE DEBUG] Creating WindowMessenger for browser mode");const t=this.createIframe(e.iframeUrl),a=new URL(e.iframeUrl).origin;r=new u({remoteWindow:t.contentWindow,allowedOrigins:[a]}),o.debugLog("[HANDSHAKE DEBUG] Created WindowMessenger")}return o.debugLog("[HANDSHAKE DEBUG] Creating IframeManager instance"),new y.IframeManager(e,this.storage,r)}async ensureSigner(){if(this.iframeManager&&this.iframeManager.hasFailed&&(o.debugLog("IframeManager has failed, clearing signer for recreation"),this.signer=null),this.signer)return this.signer;if(this.signerPromise)return this.signerPromise;this.signerPromise=this.createSigner();try{return this.signer=await this.signerPromise,this.signer}catch(e){throw this.signerPromise=null,e}finally{this.signerPromise=null}}async createSigner(){const e=await this.getIframeManager();return new d.EmbeddedSigner(e,this.storage,this.backendApiClients,this.passkeyHandler,this.eventEmitter)}createIframe(e){if("undefined"==typeof document)throw new n.OpenfortError("Document is not available. Please provide a message poster for non-browser environments.",n.OpenfortErrorType.INVALID_CONFIGURATION);const r=document.getElementById("openfort-iframe");r&&r.remove();const t=document.createElement("iframe");return t.style.display="none",t.id="openfort-iframe",t.src=e,document.body.appendChild(t),t}async getPasskeyKey(e){const r=await s.Authentication.fromStorage(this.storage);return await this.passkeyHandler.deriveAndExportKey({id:e,seed:r.player})}async getEntropy(e){switch(e.recoveryMethod){case i.RecoveryMethod.PASSWORD:return{recoveryPassword:e.password};case i.RecoveryMethod.AUTOMATIC:return{encryptionSession:e.encryptionSession};case i.RecoveryMethod.PASSKEY:return{passkey:e.passkeyInfo?{id:e.passkeyInfo.passkeyId,key:e.passkeyInfo.passkeyKey||await this.getPasskeyKey(e.passkeyInfo.passkeyId)}:{}};default:throw new n.OpenfortError("Invalid recovery method",n.OpenfortErrorType.INVALID_CONFIGURATION)}}async configure(e){await this.validateAndRefreshToken();const r=e.recoveryParams??{recoveryMethod:i.RecoveryMethod.AUTOMATIC},[t,s]=await Promise.all([this.ensureSigner(),this.getEntropy(r)]),n={chainId:e.chainId,entropy:s,accountType:e.accountType??i.AccountTypeEnum.SMART_ACCOUNT,chainType:e.chainType??i.ChainTypeEnum.EVM,getPasskeyKeyFn:async e=>this.getPasskeyKey(e)},o=await t.configure(n);return{id:o.id,chainId:o.chainId,user:o.user,address:o.address,ownerAddress:o.ownerAddress,chainType:o.chainType,accountType:o.accountType,implementationType:o.implementationType,factoryAddress:o.factoryAddress,salt:o.salt,createdAt:o.createdAt,implementationAddress:o.implementationAddress,recoveryMethod:a.Account.parseRecoveryMethod(o.recoveryMethod),recoveryMethodDetails:o.recoveryMethodDetails}}async create(e){await this.validateAndRefreshToken();const t=e.recoveryParams??{recoveryMethod:i.RecoveryMethod.AUTOMATIC},o=await s.Authentication.fromStorage(this.storage);if(!o)throw new n.OpenfortError("missing authentication",n.OpenfortErrorType.AUTHENTICATION_ERROR);if(t.recoveryMethod===i.RecoveryMethod.PASSKEY){const e=await this.passkeyHandler.createPasskey({id:r.PasskeyHandler.randomPasskeyName(),displayName:"Openfort - Embedded Wallet",seed:o?.player??""});t.passkeyInfo={passkeyId:e.id,passkeyKey:e.key}}const[d,c]=await Promise.all([this.ensureSigner(),this.getEntropy(t)]),g=await d.create({accountType:e.accountType,chainType:e.chainType,chainId:e.chainId,entropy:c}),h={id:g.id,chainId:g.chainId,user:o.player,address:g.address,ownerAddress:g.ownerAddress,chainType:g.chainType,accountType:g.accountType,implementationType:g.implementationType,factoryAddress:g.factoryAddress,salt:g.salt,createdAt:g.createdAt,implementationAddress:g.implementationAddress,recoveryMethod:a.Account.parseRecoveryMethod(g.recoveryMethod),recoveryMethodDetails:g.recoveryMethodDetails};return this.eventEmitter.emit(i.OpenfortEvents.ON_EMBEDDED_WALLET_CREATED,h),h}async recover(e){await this.validateAndRefreshToken();const r=e.recoveryParams??{recoveryMethod:i.RecoveryMethod.AUTOMATIC};if(r.recoveryMethod===i.RecoveryMethod.PASSKEY){if(!r.passkeyInfo?.passkeyId)throw new n.OpenfortError("Passkey ID must be provided for passkey recovery",n.OpenfortErrorType.INVALID_CONFIGURATION);r.passkeyInfo={passkeyId:r.passkeyInfo.passkeyId}}const[t,s]=await Promise.all([this.ensureSigner(),this.getEntropy(r)]),o=await t.recover({account:e.account,entropy:s}),d={id:o.id,chainId:o.chainId,implementationAddress:o.implementationAddress,factoryAddress:o.factoryAddress,salt:o.salt,user:o.user,address:o.address,ownerAddress:o.ownerAddress,chainType:o.chainType,accountType:o.accountType,implementationType:o.implementationType,createdAt:o.createdAt,recoveryMethod:a.Account.parseRecoveryMethod(o.recoveryMethod),recoveryMethodDetails:o.recoveryMethodDetails};return this.eventEmitter.emit(i.OpenfortEvents.ON_EMBEDDED_WALLET_RECOVERED,d),d}async signMessage(e,r){await this.validateAndRefreshToken();const t=await this.ensureSigner(),{hashMessage:s=!0,arrayifyMessage:n=!1}=r||{},i=await a.Account.fromStorage(this.storage);return await t.sign(e,n,s,i?.chainType)}async signTypedData(e,r,t){await this.validateAndRefreshToken();const s=await this.ensureSigner(),i=await a.Account.fromStorage(this.storage);if(!i)throw new n.OpenfortError("No account found",n.OpenfortErrorType.MISSING_SIGNER_ERROR);const o={...r};delete o.EIP712Domain;const{_TypedDataEncoder:d}=await import("@ethersproject/hash"),c=d.hash(e,o,t);return await h.signMessage({hash:c,implementationType:i.implementationType||i.type,chainId:Number(i.chainId),signer:s,address:i.address,ownerAddress:i.ownerAddress,factoryAddress:i.factoryAddress,salt:i.salt})}async exportPrivateKey(){await this.validateAndRefreshToken();const e=await this.ensureSigner();return await e.export()}async setRecoveryMethod(e,t){await this.validateAndRefreshToken();const o=await this.ensureSigner(),d=await s.Authentication.fromStorage(this.storage);if(!d)throw new n.OpenfortError("missing authentication",n.OpenfortErrorType.AUTHENTICATION_ERROR);let c,g,h,y;if(e.recoveryMethod===i.RecoveryMethod.PASSKEY){const e=await a.Account.fromStorage(this.storage);if(!e)throw new n.OpenfortError("missing account",n.OpenfortErrorType.INVALID_CONFIGURATION);const r=e?.recoveryMethodDetails?.passkeyId;if(!r)throw new n.OpenfortError("missing passkey id for account",n.OpenfortErrorType.INVALID_CONFIGURATION);h={passkeyId:r,passkeyKey:await this.passkeyHandler.deriveAndExportKey({id:r,seed:d.player})}}else if(t.recoveryMethod===i.RecoveryMethod.PASSKEY){const e=await this.passkeyHandler.createPasskey({id:r.PasskeyHandler.randomPasskeyName(),displayName:"Openfort - Embedded Wallet",seed:d.player});h={passkeyId:e.id,passkeyKey:e.key},y={passkeyId:e.id}}if(e.recoveryMethod===i.RecoveryMethod.PASSWORD?c=e.password:t.recoveryMethod===i.RecoveryMethod.PASSWORD&&(c=t.password),e.recoveryMethod===i.RecoveryMethod.AUTOMATIC?g=e.encryptionSession:t.recoveryMethod===i.RecoveryMethod.AUTOMATIC&&(g=t.encryptionSession),!c&&!g)throw new n.OpenfortError("Password or encryption session is not provided",n.OpenfortErrorType.INVALID_CONFIGURATION);await o.setRecoveryMethod({recoveryMethod:t.recoveryMethod,recoveryPassword:c,encryptionSession:g,passkeyInfo:h});const p=await a.Account.fromStorage(this.storage);p&&new a.Account({...p,recoveryMethod:t.recoveryMethod,recoveryMethodDetails:y}).save(this.storage)}async get(){const e=await a.Account.fromStorage(this.storage);if(!e)throw new n.OpenfortError("No signer configured",n.OpenfortErrorType.MISSING_SIGNER_ERROR);const r=await s.Authentication.fromStorage(this.storage);if(!r)throw new n.OpenfortError("No access token found",n.OpenfortErrorType.NOT_LOGGED_IN_ERROR);return{id:e.id,chainId:e.chainId,user:r.player,address:e.address,ownerAddress:e.ownerAddress,factoryAddress:e.factoryAddress,salt:e.salt,chainType:e.chainType,accountType:e.accountType,implementationAddress:e.implementationAddress,implementationType:e.implementationType,createdAt:e.createdAt,recoveryMethod:a.Account.parseRecoveryMethod(e.recoveryMethod),recoveryMethodDetails:e.recoveryMethodDetails}}async list(e){const r={accountType:i.AccountTypeEnum.SMART_ACCOUNT,...e},o=t.SDKConfiguration.getInstance();if(!o)throw new n.OpenfortError("Configuration not found",n.OpenfortErrorType.INVALID_CONFIGURATION);await this.validateAndRefreshToken();const d=await s.Authentication.fromStorage(this.storage);if(!d)throw new n.OpenfortError("No access token found",n.OpenfortErrorType.NOT_LOGGED_IN_ERROR);return n.withOpenfortError(async()=>(await this.backendApiClients.accountsApi.getAccountsV2(r,{headers:{authorization:`Bearer ${o.baseConfiguration.publishableKey}`,"x-player-token":d.token,"x-auth-provider":d.thirdPartyProvider,"x-token-type":d.thirdPartyTokenType}})).data.data.map(e=>({user:e.user,chainType:e.chainType,id:e.id,address:e.address,active:e.smartAccount?.active,ownerAddress:e.ownerAddress,factoryAddress:e.smartAccount?.factoryAddress,salt:e.smartAccount?.salt,accountType:e.accountType,implementationAddress:e.smartAccount?.implementationAddress,createdAt:e.createdAt,implementationType:e.smartAccount?.implementationType,chainId:e.chainId,recoveryMethod:a.Account.parseRecoveryMethod(e.recoveryMethod),recoveryMethodDetails:e.recoveryMethodDetails})),{default:n.OpenfortErrorType.AUTHENTICATION_ERROR})}async getEmbeddedState(){try{if(!await s.Authentication.fromStorage(this.storage))return i.EmbeddedState.UNAUTHENTICATED;return await a.Account.fromStorage(this.storage)?i.EmbeddedState.READY:i.EmbeddedState.EMBEDDED_SIGNER_NOT_CONFIGURED}catch(e){return o.debugLog("Failed to get embedded state:",e),i.EmbeddedState.UNAUTHENTICATED}}async getEthereumProvider(e){await this.ensureInitialized();const r={announceProvider:!0,...e},t=await s.Authentication.fromStorage(this.storage),n=await a.Account.fromStorage(this.storage);return this.provider?this.provider&&r.policy&&this.provider.updatePolicy(r.policy):(this.provider=new c.EvmProvider({storage:this.storage,openfortEventEmitter:this.eventEmitter,ensureSigner:this.ensureSigner.bind(this),account:n||void 0,authentication:t||void 0,backendApiClients:this.backendApiClients,policyId:r.policy,validateAndRefreshSession:this.validateAndRefreshToken.bind(this),chains:r.chains}),r.announceProvider&&g.announceProvider({info:{...g.openfortProviderInfo,...r.providerInfo},provider:this.provider})),this.provider}async ping(e){try{e>0&&await new Promise(r=>{setTimeout(r,e)});const r=await this.getIframeManager();if(!r.isLoaded())return!1;const t=await s.Authentication.fromStorage(this.storage);if(t)try{return await r.getCurrentDevice(t.player),!0}catch(e){return!1}return r.isLoaded()}catch(e){return o.debugLog("Ping failed:",e),!1}}getURL(){const e=t.SDKConfiguration.getInstance();if(!e)throw new n.OpenfortError("Configuration not found",n.OpenfortErrorType.INVALID_CONFIGURATION);return e.iframeUrl}async setMessagePoster(e){if(!e||"function"!=typeof e.postMessage)throw new n.OpenfortError("Invalid message poster",n.OpenfortErrorType.INVALID_CONFIGURATION);this.messagePoster=e,this.messenger&&this.messenger.destroy(),this.iframeManager&&this.iframeManager.destroy(),this.signer=null,this.signerPromise=null,this.iframeManager=null,this.iframeManagerPromise=null,this.messenger=null}async handleLogout(){const e=await this.ensureSigner();await e.disconnect(),this.provider=null,this.messenger=null,this.iframeManager=null,this.iframeManagerPromise=null,this.signer=null,this.signerPromise=null}async onMessage(e){if(!e||"object"!=typeof e)return void o.debugLog("Invalid message received:",e);o.debugLog("[HANDSHAKE DEBUG] EmbeddedWalletApi onMessage:",e);const r="penpal"===e.namespace&&"SYN"===e.type||e.penpal&&"string"==typeof e.penpal;if(r&&this.messenger&&this.messagePoster)return o.debugLog("[HANDSHAKE DEBUG] Passing message directly to existing ReactNativeMessenger"),void this.messenger.handleMessage(e);const t=await this.getIframeManager();o.debugLog(`[HANDSHAKE DEBUG] IframeManager obtained, isLoaded: ${t.isLoaded()}`),r&&!t.isLoaded()&&o.debugLog("[HANDSHAKE DEBUG] Received penpal message before connection initialized, setting up connection..."),o.debugLog("[HANDSHAKE DEBUG] Calling iframeManager.onMessage"),await t.onMessage(e),o.debugLog("[HANDSHAKE DEBUG] iframeManager.onMessage completed")}isReady(){return this.iframeManager?.isLoaded()||!1}};
