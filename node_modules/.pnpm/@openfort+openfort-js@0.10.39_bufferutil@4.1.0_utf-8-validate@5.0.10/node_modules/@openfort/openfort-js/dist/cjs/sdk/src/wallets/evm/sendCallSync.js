"use strict";var e=require("../../core/errors/openfortError.js"),r=require("../../types/types.js"),t=require("../../utils/authorization.js"),o=require("./JsonRpcError.js");const a=e=>{const r=e?.logs?.[0];return{blockHash:r?.blockHash,blockNumber:e?.blockNumber?.toString(),contractAddress:void 0,cumulativeGasUsed:e?.gasUsed,effectiveGasPrice:e?.gasFee,from:void 0,gasUsed:e?.gasUsed,logs:e?.logs||[],logsBloom:void 0,status:1===e?.status?"success":0===e?.status?"reverted":void 0,to:e?.to,transactionHash:e?.transactionHash,transactionIndex:r?.transactionIndex,type:"eip1559",blobGasPrice:void 0,blobGasUsed:void 0,root:void 0}};async function n(e,r){try{const t=await e.getCode(r);return"0x"!==t&&t.length>2}catch{return!1}}exports.sendCallsSync=async({params:s,signer:i,account:c,authentication:d,backendClient:p,rpcProvider:u,policyId:l})=>{const E=s[0]?.capabilities?.paymasterService?.policy??l;let T;if(c.accountType===r.AccountTypeEnum.DELEGATED_ACCOUNT){const[e,r]=await Promise.all([n(u,c.address),u.getTransactionCount(c.address)]);if(!e){const e=await t.prepareAndSignAuthorization({signer:i,accountAddress:c.address,contractAddress:c.implementationAddress,chainId:c.chainId,nonce:r});T=t.serializeSignedAuthorization(e)}}const A=await(async(r,t,a,n,s,i)=>{const c=r.map(e=>{if(!e.to)throw new o.JsonRpcError(o.RpcErrorCode.INVALID_PARAMS,'wallet_sendCalls requires a "to" field');return{to:String(e.to),data:e.data?String(e.data):void 0,value:e.value?String(e.value):void 0}});return e.withOpenfortError(async()=>(await t.transactionIntentsApi.createTransactionIntent({createTransactionIntentRequest:{account:a.id,policy:s,signedAuthorization:i,chainId:a.chainId,interactions:c}},{headers:{authorization:`Bearer ${t.config.backend.accessToken}`,"x-player-token":n.token,"x-auth-provider":n.thirdPartyProvider,"x-token-type":n.thirdPartyTokenType}})).data,{default:e.OpenfortErrorType.AUTHENTICATION_ERROR})})(s,p,c,d,E,T).catch(e=>{throw new o.JsonRpcError(o.RpcErrorCode.TRANSACTION_REJECTED,e.message)});if(A.response?.error.reason)throw new o.JsonRpcError(o.RpcErrorCode.TRANSACTION_REJECTED,A.response?.error.reason);if(A?.nextAction?.payload?.signableHash){let t;t=[300,324].includes(c.chainId)||c.implementationType&&[r.AccountType.CALIBUR].includes(c.implementationType)?await i.sign(A.nextAction.payload.signableHash,!1,!1):await i.sign(A.nextAction.payload.signableHash);const n=await e.withOpenfortError(async()=>await p.transactionIntentsApi.signature({id:A.id,signatureRequest:{signature:t}}),{default:e.OpenfortErrorType.AUTHENTICATION_ERROR}).catch(e=>{throw new o.JsonRpcError(o.RpcErrorCode.TRANSACTION_REJECTED,e.message)});if(0===n.data.response?.status)throw new o.JsonRpcError(o.RpcErrorCode.TRANSACTION_REJECTED,n.data.response?.error.reason);if(!n.data.response)throw new o.JsonRpcError(o.RpcErrorCode.TRANSACTION_REJECTED,"No transaction response received");return{id:A.id,receipt:a(n.data.response)}}if(!A.response)throw new o.JsonRpcError(o.RpcErrorCode.TRANSACTION_REJECTED,"No transaction response received");return{id:A.id,receipt:a(A.response)}};
