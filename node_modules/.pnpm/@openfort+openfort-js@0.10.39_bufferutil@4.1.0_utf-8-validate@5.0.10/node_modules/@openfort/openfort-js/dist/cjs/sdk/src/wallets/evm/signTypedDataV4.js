"use strict";var e=require("./JsonRpcError.js"),r=require("./walletHelpers.js");const a=["types","domain","primaryType","message"],t=(r,t)=>{let o;if("string"==typeof r)try{o=JSON.parse(r)}catch(r){throw new e.JsonRpcError(e.RpcErrorCode.INVALID_PARAMS,`Failed to parse typed data JSON: ${r}`)}else{if("object"!=typeof r)throw new e.JsonRpcError(e.RpcErrorCode.INVALID_PARAMS,`Invalid typed data argument: ${r}`);o=r}if(!(e=>a.every(r=>r in e))(o))throw new e.JsonRpcError(e.RpcErrorCode.INVALID_PARAMS,`Invalid typed data argument. The following properties are required: \n      ${a.join(", ")}`);const n=o.domain?.chainId;if(n&&("string"==typeof n&&(n.startsWith("0x")?o.domain.chainId=parseInt(n,16):o.domain.chainId=parseInt(n,10)),o.domain.chainId!==t))throw new e.JsonRpcError(e.RpcErrorCode.INVALID_PARAMS,`Invalid chainId, expected ${t}`);return o};exports.signTypedDataV4=async({params:a,method:o,signer:n,implementationType:s,rpcProvider:d,account:i})=>{const p=a[0],c=a[1];if(!p||!c)throw new e.JsonRpcError(e.RpcErrorCode.INVALID_PARAMS,`${o} requires an address and a typed data JSON`);const{chainId:h}=await d.detectNetwork(),I=t(c,h),y={...I.types};delete y.EIP712Domain;const{_TypedDataEncoder:m}=await import("@ethersproject/hash"),A=m.hash(I.domain,y,I.message);return await r.signMessage({hash:A,implementationType:s,chainId:h,signer:n,address:p,ownerAddress:i.ownerAddress,factoryAddress:i.factoryAddress,salt:i.salt})};
