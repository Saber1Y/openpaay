"use strict";var R,E=require("axios");exports.OpenfortErrorType=void 0,(R=exports.OpenfortErrorType||(exports.OpenfortErrorType={})).AUTHENTICATION_ERROR="AUTHENTICATION_ERROR",R.INVALID_CONFIGURATION="INVALID_CONFIGURATION",R.NOT_LOGGED_IN_ERROR="NOT_LOGGED_IN_ERROR",R.ALREADY_LOGGED_IN_ERROR="ALREADY_LOGGED_IN_ERROR",R.REFRESH_TOKEN_ERROR="REFRESH_TOKEN_ERROR",R.USER_REGISTRATION_ERROR="USER_REGISTRATION_ERROR",R.LOGOUT_ERROR="LOGOUT_ERROR",R.OPERATION_NOT_SUPPORTED_ERROR="OPERATION_NOT_SUPPORTED_ERROR",R.MISSING_SIGNER_ERROR="MISSING_SIGNER_ERROR",R.USER_NOT_AUTHORIZED_ON_ECOSYSTEM="USER_NOT_AUTHORIZED_ON_ECOSYSTEM",R.INTERNAL_ERROR="INTERNAL_ERROR";class O extends Error{type;data;constructor(R,E,O={}){super(R),this.type=E,this.data=O}}exports.OpenfortError=O,exports.withOpenfortError=async(R,r,e)=>{try{return await R()}catch(R){let _;const t={};let s;E.isAxiosError(R)?(s=R.response?.status,_=R.response?.data?.error&&function(R){return"type"in R&&"message"in R}(R.response.data.error)?R.response.data.error.message:R.message):_=R.message;const N=void 0!==s&&r[s]?r[s]:r.default,o=new O(_,N,t);throw void 0!==s&&r[s]||e?.(R,o),o}};
