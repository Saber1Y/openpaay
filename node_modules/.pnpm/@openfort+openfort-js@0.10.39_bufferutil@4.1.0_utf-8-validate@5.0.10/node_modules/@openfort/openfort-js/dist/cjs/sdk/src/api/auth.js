"use strict";var t=require("../core/configuration/authentication.js"),e=require("../core/errors/openfortError.js"),i=require("../types/types.js");exports.AuthApi=class{storage;authManager;validateAndRefreshToken;ensureInitialized;eventEmitter;constructor(t,e,i,a,r){this.storage=t,this.authManager=e,this.validateAndRefreshToken=i,this.ensureInitialized=a,this.eventEmitter=r}async logInWithEmailPassword({email:a,password:r,ecosystemGame:n}){await this.ensureInitialized();if(await t.Authentication.fromStorage(this.storage))throw new e.OpenfortError("Already logged in",e.OpenfortErrorType.ALREADY_LOGGED_IN_ERROR);this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_INIT,{method:"email",provider:"email"});try{const e=await this.authManager.loginEmailPassword(a,r,n);return"action"in e||(new t.Authentication("jwt",e.token,e.player.id,e.refreshToken).save(this.storage),this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_SUCCESS,e)),e}catch(t){throw this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_FAILURE,t),t}}async signUpGuest(){await this.ensureInitialized();if(await t.Authentication.fromStorage(this.storage))throw new e.OpenfortError("Already logged in",e.OpenfortErrorType.ALREADY_LOGGED_IN_ERROR);this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_INIT,{method:"guest"});try{const e=await this.authManager.registerGuest();return new t.Authentication("jwt",e.token,e.player.id,e.refreshToken).save(this.storage),this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_SUCCESS,e),e}catch(t){throw this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_FAILURE,t),t}}async signUpWithEmailPassword({email:a,password:r,options:n,ecosystemGame:s}){await this.ensureInitialized();if(await t.Authentication.fromStorage(this.storage))throw new e.OpenfortError("Already logged in",e.OpenfortErrorType.ALREADY_LOGGED_IN_ERROR);this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_INIT,{method:"email",provider:"email"});try{const e=await this.authManager.signupEmailPassword(a,r,n?.data.name,s);return"action"in e||(new t.Authentication("jwt",e.token,e.player.id,e.refreshToken).save(this.storage),this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_SUCCESS,e)),e}catch(t){throw this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_FAILURE,t),t}}async linkEmailPassword({email:t,password:e,authToken:i,ecosystemGame:a}){return await this.validateAndRefreshToken(),await this.authManager.linkEmail(t,e,i,a)}async unlinkEmailPassword({email:t,authToken:e}){return await this.validateAndRefreshToken(),await this.authManager.unlinkEmail(t,e)}async requestEmailVerification({email:t,redirectUrl:e}){await this.ensureInitialized(),await this.authManager.requestEmailVerification(t,e)}async resetPassword({email:t,password:e,state:i}){await this.ensureInitialized(),await this.authManager.resetPassword(t,e,i)}async requestResetPassword({email:t,redirectUrl:e}){await this.ensureInitialized(),await this.authManager.requestResetPassword(t,e)}async verifyEmail({email:t,state:e}){await this.ensureInitialized(),await this.authManager.verifyEmail(t,e)}async initOAuth({provider:a,options:r,ecosystemGame:n}){await this.ensureInitialized();if(await t.Authentication.fromStorage(this.storage))throw new e.OpenfortError("Already logged in",e.OpenfortErrorType.ALREADY_LOGGED_IN_ERROR);return this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_INIT,{method:"oauth",provider:a}),await this.authManager.initOAuth(a,r,n)}async initLinkOAuth({provider:a,options:r,ecosystemGame:n}){await this.validateAndRefreshToken();const s=await t.Authentication.fromStorage(this.storage);if(!s)throw new e.OpenfortError("No authentication found",e.OpenfortErrorType.NOT_LOGGED_IN_ERROR);return this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_INIT,{method:"oauth",provider:a}),await this.authManager.linkOAuth(s,a,r,n)}async unlinkOAuth({provider:t,authToken:e}){return await this.validateAndRefreshToken(),await this.authManager.unlinkOAuth(t,e)}async poolOAuth(e){await this.ensureInitialized();try{const a=await this.authManager.poolOAuth(e);return new t.Authentication("jwt",a.token,a.player.id,a.refreshToken).save(this.storage),this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_SUCCESS,a),a}catch(t){throw this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_FAILURE,t),t}}async loginWithIdToken({provider:a,token:r,ecosystemGame:n}){await this.ensureInitialized();if(await t.Authentication.fromStorage(this.storage))throw new e.OpenfortError("Already logged in",e.OpenfortErrorType.ALREADY_LOGGED_IN_ERROR);this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_INIT,{method:"idToken",provider:a});try{const e=await this.authManager.loginWithIdToken(a,r,n);return new t.Authentication("jwt",e.token,e.player.id,e.refreshToken).save(this.storage),this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_SUCCESS,e),e}catch(t){throw this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_FAILURE,t),t}}async initSIWE({address:t,ecosystemGame:e}){return await this.ensureInitialized(),await this.authManager.initSIWE(t,e)}async authenticateWithSIWE({signature:a,message:r,walletClientType:n,connectorType:s}){await this.ensureInitialized();if(await t.Authentication.fromStorage(this.storage))throw new e.OpenfortError("Already logged in",e.OpenfortErrorType.ALREADY_LOGGED_IN_ERROR);this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_INIT,{method:"siwe",provider:"wallet"});try{const e=await this.authManager.authenticateSIWE(a,r,n,s);return new t.Authentication("jwt",e.token,e.player.id,e.refreshToken).save(this.storage),this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_SUCCESS,e),e}catch(t){throw this.eventEmitter.emit(i.OpenfortEvents.ON_AUTH_FAILURE,t),t}}async linkWallet({signature:t,message:e,walletClientType:i,connectorType:a,authToken:r}){return await this.validateAndRefreshToken(),await this.authManager.linkWallet(t,e,i,a,r)}async unlinkWallet({address:t,authToken:e}){return await this.validateAndRefreshToken(),await this.authManager.unlinkWallet(t,e)}async storeCredentials(i){if(await this.ensureInitialized(),!i.player)throw new e.OpenfortError("Player ID is required to store credentials",e.OpenfortErrorType.INVALID_CONFIGURATION);new t.Authentication("jwt",i.accessToken,i.player,i.refreshToken).save(this.storage)}async logout(){const e=await t.Authentication.fromStorage(this.storage);if(e){try{"third_party"!==e.type&&await this.authManager.logout(e.token,e.refreshToken??"")}catch(t){}t.Authentication.clear(this.storage),this.eventEmitter.emit(i.OpenfortEvents.ON_LOGOUT)}}};
