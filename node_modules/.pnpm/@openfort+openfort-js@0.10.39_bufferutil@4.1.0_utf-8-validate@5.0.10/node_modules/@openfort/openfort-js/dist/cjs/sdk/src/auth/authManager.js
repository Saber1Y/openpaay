"use strict";var e=require("jose"),t=require("../utils/debug.js"),r=require("../core/errors/openfortError.js"),a=require("../core/errors/sentry.js"),n=require("../storage/istorage.js"),i=require("../types/types.js"),o=require("../utils/crypto.js");async function s(e){const t=(new TextEncoder).encode(e),r=await o.cryptoDigest("SHA-256",t);return new Uint8Array(r)}function p(e){const t=new Uint8Array(e);return crypto.getRandomValues(t),t}class d{decodedPayload;value;constructor(t){this.value=t;try{this.decodedPayload=e.decodeJwt(t)}catch(e){throw new r.OpenfortError("Invalid token format",r.OpenfortErrorType.AUTHENTICATION_ERROR)}}get subject(){return this.decodedPayload.sub}get expiration(){return this.decodedPayload.exp}get issuer(){return this.decodedPayload.iss}isExpired(e=30){return!this.expiration||(t.debugLog("Token expiration:",1e3*(this.expiration-e),"Current time:",Date.now()),Date.now()>=1e3*(this.expiration-e))}static parse(e){try{return new d(e)}catch{return null}}}class c{storage;constructor(e){this.storage=e}async savePKCEData(e){this.storage.save(n.StorageKeys.PKCE_STATE,e.state),this.storage.save(n.StorageKeys.PKCE_VERIFIER,e.verifier)}async getPKCEData(){const e=await this.storage.get(n.StorageKeys.PKCE_STATE),t=await this.storage.get(n.StorageKeys.PKCE_VERIFIER);return e&&t?{state:e,verifier:t}:null}async clearPKCEData(){this.storage.remove(n.StorageKeys.PKCE_STATE),this.storage.remove(n.StorageKeys.PKCE_VERIFIER)}}class u{deviceCredentialsManager;backendApiClientsInstance;publishableKeyInstance;constructor(e){this.deviceCredentialsManager=new c(e)}setBackendApiClients(e,t){this.backendApiClientsInstance=e,this.publishableKeyInstance=t}get backendApiClients(){if(!this.backendApiClientsInstance)throw new r.OpenfortError("Backend API clients not initialized",r.OpenfortErrorType.INTERNAL_ERROR);return this.backendApiClientsInstance}get publishableKey(){if(!this.publishableKeyInstance)throw new r.OpenfortError("Publishable key not initialized",r.OpenfortErrorType.INTERNAL_ERROR);return this.publishableKeyInstance}async initOAuth(e,t,a){const n=t?.usePooling??!1,i=t?.skipBrowserRedirect??!1,{usePooling:o,skipBrowserRedirect:s,...p}=t||{},d={oAuthInitRequest:{provider:e,options:p,usePooling:n}},c=await r.withOpenfortError(async()=>this.backendApiClients.authenticationApi.initOAuth(d,u.getEcosystemGameOptsOrUndefined(a)),{default:r.OpenfortErrorType.AUTHENTICATION_ERROR});return"undefined"==typeof window||i||window.location.assign(c.data.url),{url:c.data.url,key:c.data.key}}async registerGuest(){const e={};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.registerGuest(e)).data,{default:r.OpenfortErrorType.USER_REGISTRATION_ERROR})}async poolOAuth(e){const t={key:e};for(let e=0;e<600;e++)try{const e=await r.withOpenfortError(async()=>this.backendApiClients.authenticationApi.poolOAuth(t),{default:r.OpenfortErrorType.AUTHENTICATION_ERROR});if(200===e.status)return e.data}catch(e){if(e.response&&404===e.response.status){await new Promise(e=>{setTimeout(e,500)});continue}throw e}throw new Error("Failed to pool OAuth, try again later")}async loginWithIdToken(e,t,n){const i={loginWithIdTokenRequest:{provider:e,token:t}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.loginWithIdToken(i,u.getEcosystemGameOptsOrUndefined(n))).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR,401:r.OpenfortErrorType.AUTHENTICATION_ERROR,403:r.OpenfortErrorType.USER_NOT_AUTHORIZED_ON_ECOSYSTEM},e=>{a.sentry.captureAxiosError("loginWithIdToken",e)})}async authenticateThirdParty(e,t,n,i){const o={thirdPartyOAuthRequest:{provider:e,token:t,tokenType:n}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.thirdParty(o,u.getEcosystemGameOptsOrUndefined(i))).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR,401:r.OpenfortErrorType.AUTHENTICATION_ERROR,403:r.OpenfortErrorType.USER_NOT_AUTHORIZED_ON_ECOSYSTEM},e=>{a.sentry.captureAxiosError("authenticateThirdParty",e)})}async initSIWE(e,t){const a={sIWERequest:{address:e}},n=await r.withOpenfortError(async()=>this.backendApiClients.authenticationApi.initSIWE(a,u.getEcosystemGameOptsOrUndefined(t)),{default:r.OpenfortErrorType.AUTHENTICATION_ERROR});return{address:n.data.address,nonce:n.data.nonce,expiresAt:n.data.expiresAt}}async authenticateSIWE(e,t,n,i){const o={sIWEAuthenticateRequest:{signature:e,message:t,walletClientType:n,connectorType:i}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.authenticateSIWE(o)).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR,401:r.OpenfortErrorType.AUTHENTICATION_ERROR,403:r.OpenfortErrorType.USER_NOT_AUTHORIZED_ON_ECOSYSTEM},e=>{a.sentry.captureAxiosError("authenticateSIWE",e)})}static getEcosystemGameOptsOrUndefined(e){if(e)return{headers:{"x-game":e}}}async loginEmailPassword(e,t,n){const i={loginRequest:{email:e,password:t}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.loginEmailPassword(i,u.getEcosystemGameOptsOrUndefined(n))).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR,401:r.OpenfortErrorType.AUTHENTICATION_ERROR,403:r.OpenfortErrorType.USER_NOT_AUTHORIZED_ON_ECOSYSTEM},e=>{a.sentry.captureAxiosError("loginEmailPassword",e)})}async requestResetPassword(t,a){const n=p(32),o=e.base64url.encode(n),d=await s(o),c=e.base64url.encode(d),u=p(32),l=e.base64url.encode(u);await this.deviceCredentialsManager.savePKCEData({state:l,verifier:o});const h={requestResetPasswordRequest:{email:t,redirectUrl:a,challenge:{codeChallenge:c,method:i.CodeChallengeMethodEnum.S256}}};await r.withOpenfortError(async()=>{await this.backendApiClients.authenticationApi.requestResetPassword(h)},{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async resetPassword(e,t,a){return r.withOpenfortError(async()=>{const r=await this.deviceCredentialsManager.getPKCEData();if(!r)throw new Error("No code verifier or state for PKCE");const n={resetPasswordRequest:{email:e,password:t,state:a,challenge:{codeVerifier:r.verifier}}};await this.backendApiClients.authenticationApi.resetPassword(n)},{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async requestEmailVerification(t,a){const n=p(32),o=e.base64url.encode(n),d=await s(o),c=e.base64url.encode(d),u=p(32),l=e.base64url.encode(u);await this.deviceCredentialsManager.savePKCEData({state:l,verifier:o});const h={requestVerifyEmailRequest:{email:t,redirectUrl:a,challenge:{codeChallenge:c,method:i.CodeChallengeMethodEnum.S256}}};await r.withOpenfortError(async()=>{await this.backendApiClients.authenticationApi.requestEmailVerification(h)},{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async verifyEmail(e,t){return r.withOpenfortError(async()=>{const r=await this.deviceCredentialsManager.getPKCEData();if(!r)throw new Error("No code verifier or state for PKCE");const a={verifyEmailRequest:{email:e,token:t,challenge:{codeVerifier:r.verifier}}};await this.backendApiClients.authenticationApi.verifyEmail(a)},{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async signupEmailPassword(e,t,n,i){const o={signupRequest:{email:e,password:t,name:n}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.signupEmailPassword(o,u.getEcosystemGameOptsOrUndefined(i))).data,{default:r.OpenfortErrorType.USER_REGISTRATION_ERROR,401:r.OpenfortErrorType.USER_REGISTRATION_ERROR,403:r.OpenfortErrorType.USER_NOT_AUTHORIZED_ON_ECOSYSTEM},e=>{a.sentry.captureAxiosError("signupEmailPassword",e)})}async validateCredentials(e,a){if(!e.refreshToken)throw new r.OpenfortError("No refresh token provided",r.OpenfortErrorType.AUTHENTICATION_ERROR);if(a)return this.refreshTokens(e.refreshToken,a);t.debugLog("Validating credentials with token:",e.token);const n=d.parse(e.token);return n?n.isExpired()?(t.debugLog("Token expired, refreshing..."),this.refreshTokens(e.refreshToken)):{player:n.subject,accessToken:e.token,refreshToken:e.refreshToken}:this.refreshTokens(e.refreshToken)}async refreshTokens(e,t){const a={refreshTokenRequest:{refreshToken:e,forceRefresh:t}};return r.withOpenfortError(async()=>{const e=await this.backendApiClients.authenticationApi.refresh(a);return{player:e.data.player.id,accessToken:e.data.token,refreshToken:e.data.refreshToken}},{default:r.OpenfortErrorType.REFRESH_TOKEN_ERROR})}async logout(e,t){const a={logoutRequest:{refreshToken:t}};return r.withOpenfortError(async()=>{await this.backendApiClients.authenticationApi.logout(a,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":e}})},{default:r.OpenfortErrorType.LOGOUT_ERROR})}async getUser(e){return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.me({headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":e.token,"x-auth-provider":e.thirdPartyProvider,"x-token-type":e.thirdPartyTokenType}})).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async linkThirdParty(e,t,a,n,i){const o={thirdPartyLinkRequest:{provider:t,token:a,tokenType:n}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.linkThirdParty(o,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":e.token,"x-auth-provider":e.thirdPartyProvider||void 0,"x-token-type":e.thirdPartyTokenType||void 0,"x-game":i||void 0}})).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async linkOAuth(e,t,a,n){const i=a?.skipBrowserRedirect??!1;delete a?.skipBrowserRedirect;const o={oAuthInitRequest:{provider:t,options:a,usePooling:a?.usePooling||!1}},s=await r.withOpenfortError(async()=>this.backendApiClients.authenticationApi.linkOAuth(o,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":e.token,"x-auth-provider":e.thirdPartyProvider||void 0,"x-token-type":e.thirdPartyTokenType||void 0,"x-game":n||void 0}}),{default:r.OpenfortErrorType.AUTHENTICATION_ERROR});return"undefined"==typeof window||i||window.location.assign(s.data.url),{url:s.data.url,key:s.data.key}}async unlinkOAuth(e,t){const a={unlinkOAuthRequest:{provider:e}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.unlinkOAuth(a,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":t}})).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async unlinkWallet(e,t){const a={sIWERequest:{address:e}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.unlinkSIWE(a,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":t}})).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async linkWallet(e,t,a,n,i){const o={sIWEAuthenticateRequest:{signature:e,message:t,walletClientType:a,connectorType:n}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.linkSIWE(o,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":i}})).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async unlinkEmail(e,t){const a={unlinkEmailRequest:{email:e}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.unlinkEmail(a,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":t}})).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}async linkEmail(e,t,a,n){const i={loginRequest:{email:e,password:t}};return r.withOpenfortError(async()=>(await this.backendApiClients.authenticationApi.linkEmail(i,{headers:{authorization:`Bearer ${this.publishableKey}`,"x-player-token":a,"x-game":n||void 0}})).data,{default:r.OpenfortErrorType.AUTHENTICATION_ERROR})}}exports.AuthManager=u;
