"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShieldSDK = void 0;
const axios_1 = __importDefault(require("axios"));
const axios_retry_1 = __importDefault(require("axios-retry"));
const EncryptionPartMissingError_1 = require("../errors/EncryptionPartMissingError");
const NoSecretFoundError_1 = require("../errors/NoSecretFoundError");
const OTPError_1 = require("../errors/OTPError");
const SecretAlreadyExistsError_1 = require("../errors/SecretAlreadyExistsError");
class ShieldSDK {
    constructor({ baseURL = 'https://shield.openfort.io', apiKey, }) {
        this._requestRetries = 3;
        this._retryDelayFunc = (retryCount) => 500 * 2 ** retryCount;
        this._requestIdHeader = 'x-request-id';
        this._apiKey = apiKey;
        this._baseURL = baseURL;
        this.initAxiosClient();
    }
    initAxiosClient() {
        this._client = axios_1.default.create({ baseURL: this._baseURL });
        (0, axios_retry_1.default)(this._client, {
            retries: this._requestRetries,
            retryDelay: this._retryDelayFunc,
            retryCondition: (error) => axios_retry_1.default.isNetworkOrIdempotentRequestError(error) ||
                error.response?.status >= axios_1.default.HttpStatusCode.InternalServerError,
        });
    }
    displayableAxiosError(err) {
        if (axios_1.default.isAxiosError(err)) {
            const code = err.code ?? 'NO_CODE';
            const status = err.response?.status ?? 'NO_STATUS';
            const body = err.response?.data
                ? JSON.stringify(err.response.data)
                : 'NO_BODY';
            return `[AxiosError] ${err.message}, code=${code}, status=${status}, body=${body}`;
        }
        return String(err);
    }
    throwableAxiosError(err) {
        const errorString = this.displayableAxiosError(err);
        return errorString;
    }
    async keychain(auth, reference, requestId) {
        try {
            const url = reference
                ? `${this._baseURL}/keychain?reference=${reference}`
                : `${this._baseURL}/keychain`;
            const response = await this._client.get(url, {
                headers: this.getAuthHeaders(auth, requestId),
            });
            const data = response.data;
            return data.shares.map((share) => {
                return {
                    secret: share.secret,
                    entropy: share.entropy,
                    encryptionParameters: {
                        salt: share.salt,
                        iterations: share.iterations,
                        length: share.length,
                        digest: share.digest,
                    },
                    keychainId: share.keychain_id,
                    reference: share.reference,
                };
            });
        }
        catch (error) {
            throw new Error(this.throwableAxiosError(error));
        }
    }
    async getSecretByReference(auth, reference, requestId) {
        try {
            const response = await this._client.get(`${this._baseURL}/shares/${reference}`, { headers: this.getAuthHeaders(auth, requestId) });
            const data = await response.data;
            return {
                secret: data.secret,
                entropy: data.entropy,
                encryptionParameters: {
                    salt: data.salt,
                    iterations: data.iterations,
                    length: data.length,
                    digest: data.digest,
                },
                keychainId: data.keychain_id,
                reference: data.reference,
            };
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                if (error.response.status === axios_1.default.HttpStatusCode.NotFound) {
                    throw new NoSecretFoundError_1.NoSecretFoundError('No secret found for the given auth options');
                }
                const errorContent = error.response.data;
                if (errorContent.code.includes('EC_MISSING')) {
                    throw new EncryptionPartMissingError_1.EncryptionPartMissingError('Encryption part missing');
                }
                if (errorContent.code.includes('OTP_MISSING')) {
                    throw new OTPError_1.OTPRequiredError('Encrypted session should be created with OTP');
                }
            }
            throw new Error(this.throwableAxiosError(error));
        }
    }
    async getSecret(auth, requestId) {
        try {
            const response = await this._client.get(`${this._baseURL}/shares`, {
                headers: this.getAuthHeaders(auth, requestId),
            });
            const data = await response.data;
            return {
                secret: data.secret,
                entropy: data.entropy,
                encryptionParameters: {
                    salt: data.salt,
                    iterations: data.iterations,
                    length: data.length,
                    digest: data.digest,
                },
                keychainId: data.keychain_id,
                reference: data.reference,
            };
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                if (error.response.status === axios_1.default.HttpStatusCode.NotFound) {
                    throw new NoSecretFoundError_1.NoSecretFoundError('No secret found for the given auth options');
                }
                const errorContent = error.response.data;
                if (errorContent.code.includes('EC_MISSING')) {
                    throw new EncryptionPartMissingError_1.EncryptionPartMissingError('Encryption part missing');
                }
                if (errorContent.code.includes('OTP_MISSING')) {
                    throw new OTPError_1.OTPRequiredError('Encrypted session should be created with OTP');
                }
            }
            throw new Error(this.throwableAxiosError(error));
        }
    }
    async updateSecret(auth, share, requestId) {
        try {
            const passkeyReferenceBody = share.passkeyReference
                ? {
                    passkey_id: share.passkeyReference.passkeyId,
                    passkey_env: share.passkeyReference.passkeyEnv,
                }
                : null;
            const requestBody = {
                secret: share.secret,
                entropy: share.entropy,
                salt: share.encryptionParameters?.salt,
                iterations: share.encryptionParameters?.iterations,
                length: share.encryptionParameters?.length,
                digest: share.encryptionParameters?.digest,
                encryption_part: auth.encryptionPart || '',
                encryption_session: auth.encryptionSession || '',
                reference: share.reference || '',
                keychain_id: share.keychainId || '',
                passkey_reference: passkeyReferenceBody,
            };
            await this._client.put(`${this._baseURL}/shares`, requestBody, {
                headers: this.getAuthHeaders(auth, requestId),
            });
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) &&
                error.response &&
                error.response.data.code.includes('EC_MISSING')) {
                throw new EncryptionPartMissingError_1.EncryptionPartMissingError('Encryption part missing');
            }
            throw new Error(this.throwableAxiosError(error));
        }
    }
    async deleteSecret(auth, requestId, reference) {
        try {
            let url = `${this._baseURL}/shares`;
            if (reference && reference !== null && reference !== undefined) {
                url = `${url}/${reference}`;
            }
            const _response = await this._client.delete(url, {
                headers: this.getAuthHeaders(auth, requestId),
            });
        }
        catch (error) {
            throw new Error(this.throwableAxiosError(error));
        }
    }
    getEnvOption(opt) {
        return opt?.toLowerCase() !== 'unknown' ? opt : undefined;
    }
    getPasskeyEnv(info) {
        return (info && {
            name: this.getEnvOption(info.name),
            os: this.getEnvOption(info.os),
            osVersion: this.getEnvOption(info.osVersion),
            device: this.getEnvOption(info.device),
        });
    }
    getDetails(info) {
        const passkeyId = info?.passkey_id;
        return passkeyId
            ? { passkeyId, passkeyEnv: this.getPasskeyEnv(info.passkey_env) }
            : undefined;
    }
    async getEncryptionMethodBulk(url, bodyListname, auth, keys, requestId, reference) {
        // both methods (references and users) expect a similar input JSON
        // reference/bulk expects "references": string[] and user/bulk expects "user_ids": string[]
        try {
            const response = await this._client.post(url, { [bodyListname]: keys, reference: reference }, { headers: this.getAuthHeaders(auth, requestId) });
            const data = response.data;
            const returnValue = new Map();
            for (const key in data.encryption_types) {
                const info = data.encryption_types[key];
                // Shield returns either found or not found regardless of input references/users to avoid falling
                // in "snitchy" 403 situations, we'll only care about found occurences here though
                if (info.status === 'found') {
                    returnValue.set(key, {
                        method: info.encryption_type,
                        details: this.getDetails(info),
                    });
                }
            }
            return returnValue;
        }
        catch (error) {
            throw new Error(this.throwableAxiosError(error));
        }
    }
    async getEncryptionMethodsBySignerReferencesDetailed(auth, signers, requestId) {
        return this.getEncryptionMethodBulk(`${this._baseURL}/shares/encryption/reference/bulk`, 'references', auth, signers, requestId);
    }
    async getEncryptionMethodsByOwnerIdDetailed(auth, users, requestId, reference) {
        return this.getEncryptionMethodBulk(`${this._baseURL}/shares/encryption/user/bulk`, 'user_ids', auth, users, requestId, reference);
    }
    simplifyEncryptionMethodMap(enrichedMap) {
        return new Map(Array.from(enrichedMap.entries()).map(([key, enrichedValue]) => [
            key,
            enrichedValue.method,
        ]));
    }
    async getEncryptionMethodsBySignerReferences(auth, signers, requestId) {
        const detailedMap = await this.getEncryptionMethodBulk(`${this._baseURL}/shares/encryption/reference/bulk`, 'references', auth, signers, requestId);
        return this.simplifyEncryptionMethodMap(detailedMap);
    }
    async getEncryptionMethodsByOwnerId(auth, users, requestId) {
        const detailedMap = await this.getEncryptionMethodBulk(`${this._baseURL}/shares/encryption/user/bulk`, 'user_ids', auth, users, requestId);
        return this.simplifyEncryptionMethodMap(detailedMap);
    }
    async createSecret(path, share, auth, requestId) {
        try {
            const passkeyReferenceBody = share.passkeyReference
                ? {
                    passkey_id: share.passkeyReference.passkeyId,
                    passkey_env: share.passkeyReference.passkeyEnv,
                }
                : null;
            const requestBody = {
                secret: share.secret,
                entropy: share.entropy,
                salt: share.encryptionParameters?.salt,
                iterations: share.encryptionParameters?.iterations,
                length: share.encryptionParameters?.length,
                digest: share.encryptionParameters?.digest,
                encryption_part: auth.encryptionPart || '',
                encryption_session: auth.encryptionSession || '',
                reference: share.reference || '',
                keychain_id: share.keychainId || '',
                passkey_reference: passkeyReferenceBody,
            };
            await this._client.post(`${this._baseURL}/${path}`, requestBody, {
                headers: this.getAuthHeaders(auth, requestId),
            });
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error) && error.response) {
                if (error.response.data.code.includes('EC_MISSING')) {
                    throw new EncryptionPartMissingError_1.EncryptionPartMissingError('Encryption part missing');
                }
                if (error.response.status === axios_1.default.HttpStatusCode.Conflict) {
                    throw new SecretAlreadyExistsError_1.SecretAlreadyExistsError('Secret already exists for the given auth options');
                }
            }
            throw new Error(this.throwableAxiosError(error));
        }
    }
    async preRegister(share, auth, requestId) {
        await this.createSecret('admin/preregister', share, auth, requestId);
    }
    async storeSecret(share, auth, requestId) {
        await this.createSecret('shares', share, auth, requestId);
    }
    isOpenfortAuthOptions(options) {
        return 'openfortOAuthToken' in options;
    }
    isCustomAuthOptions(options) {
        return 'customToken' in options;
    }
    getAuthHeaders(options, requestId) {
        const headers = {
            'x-api-key': this._apiKey,
            'x-auth-provider': options.authProvider,
            'Access-Control-Allow-Origin': this._baseURL,
        };
        if (requestId) {
            headers[this._requestIdHeader] = requestId;
        }
        if (options.externalUserId) {
            headers['x-user-id'] = options.externalUserId;
        }
        if (options.apiKey) {
            headers['x-api-key'] = options.apiKey;
        }
        if (options.apiSecret) {
            headers['x-api-secret'] = options.apiSecret;
        }
        if (options.encryptionPart) {
            headers['x-encryption-part'] = options.encryptionPart;
        }
        if (options.encryptionSession) {
            headers['x-encryption-session'] = options.encryptionSession;
        }
        if (this.isOpenfortAuthOptions(options)) {
            headers.Authorization = `Bearer ${options.openfortOAuthToken}`;
            if (options.openfortOAuthProvider) {
                headers['x-openfort-provider'] = options.openfortOAuthProvider;
            }
            if (options.openfortOAuthTokenType) {
                headers['x-openfort-token-type'] = options.openfortOAuthTokenType;
            }
        }
        if (this.isCustomAuthOptions(options)) {
            headers.Authorization = `Bearer ${options.customToken}`;
        }
        return headers;
    }
}
exports.ShieldSDK = ShieldSDK;
//# sourceMappingURL=ShieldSDK.js.map